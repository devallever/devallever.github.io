{"meta":{"title":"Allever Blog","subtitle":"Android Developer","description":"Android Developer","author":"Allever","url":"https://devallever.github.io"},"pages":[{"title":"","date":"2017-04-21T08:42:35.918Z","updated":"2017-04-21T08:42:35.918Z","comments":false,"path":"categories/index.html","permalink":"https://devallever.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-21T08:41:34.775Z","updated":"2017-04-21T08:41:34.775Z","comments":false,"path":"tags/index.html","permalink":"https://devallever.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 线程池","slug":"java-thread-pool-executor-basic","date":"2017-07-02T08:35:49.000Z","updated":"2017-07-02T09:42:58.460Z","comments":true,"path":"2017/07/02/java-thread-pool-executor-basic/","link":"","permalink":"https://devallever.github.io/2017/07/02/java-thread-pool-executor-basic/","excerpt":"","text":"引言当我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。 ThreadPoolEXecutor合理利用线程池能够带来三个好处。 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。 构造方法详解构造方法有三个：其一：12345678910public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 其二：1234567891011public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)&#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);&#125; 其三：1234567891011public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125; 源码对各个参数介绍如下12345678910111213141516171819202122232425/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code handler&#125; is null */ 看不懂？没关系，下面一一解释 corePoolSize：线程池的核心线程数当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。 maximumPoolSize：线程池所能容纳的最大线程数如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。 keepAliveTime：非核心线程闲置时的超时时长线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。 unit：用于指定keepAliveTime参数的时间单位可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(TimeUnit.MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。常用的有分钟，秒，毫秒 workQueue：任务队列用于保存等待执行的任务的阻塞队列。有一下几种 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 handler：饱和策略(不常用)当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。 AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。 当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。 四种常用的线程池FixedThreadPool是一种线程数量固定的线程池，当线程处于空闲状态时，它们并不会回收，除非线程池关闭了。当所有线程都处于活动状态时，新任务都会处于等待状态，知道有线程空闲出来。由于FixedThreadPool只有核心线程并且这些核心线程都不会被回收，意味着它能够更加快速的响应外界的请求。没有超时机制，任务队列也没有大小限制。 创建实例1ExecutorService fixedThreadPoolExecutor = Executors.newFixedThreadPool(3); newFixedThreadPool()方法定义如下：1234567891011121314151617181920/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 举个例子：1234567891011121314151617181920212223private static void fixedThreadPoolTest()&#123; ExecutorService fixedThreadPoolExecutor = Executors.newFixedThreadPool(3); for (int i=0; i&lt;10; i++)&#123; final int index = i; System.out.println(System.currentTimeMillis() + &quot;in main thread index = &quot; + index + &quot; &quot; + &quot;Thread id = &quot; + Thread.currentThread().getId()); fixedThreadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(System.currentTimeMillis() + &quot;in thread pool index = &quot; + index + &quot; &quot; + &quot;Thread id = &quot; + Thread.currentThread().getId()); try &#123; Thread.sleep(2000); &#125;catch (InterruptedException itre)&#123; itre.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 运行结果12345678910111213141516171819202122231498982458294in main thread index = 0 Thread id = 11498982458296in main thread index = 1 Thread id = 11498982458296in thread pool index = 0 Thread id = 101498982458296in main thread index = 2 Thread id = 11498982458302in thread pool index = 1 Thread id = 111498982458302in main thread index = 3 Thread id = 11498982458303in main thread index = 4 Thread id = 11498982458303in main thread index = 5 Thread id = 11498982458303in main thread index = 6 Thread id = 11498982458303in main thread index = 7 Thread id = 11498982458303in main thread index = 8 Thread id = 11498982458303in main thread index = 9 Thread id = 11498982458304in thread pool index = 2 Thread id = 12// 睡两秒1498982460296in thread pool index = 3 Thread id = 101498982460303in thread pool index = 4 Thread id = 111498982460304in thread pool index = 5 Thread id = 12// 睡两秒1498982462297in thread pool index = 6 Thread id = 101498982462303in thread pool index = 7 Thread id = 111498982462304in thread pool index = 8 Thread id = 12// 睡两秒1498982464297in thread pool index = 9 Thread id = 10 可以看到主线程很快就执行完了，它只负责创建了10个任务。然后交给线程池执行。线程池数量为3，因此每次只执行其中3个任务，即打印连续3条记录，执行线程为10,11,12，其余任务处于等待状态。然后等待两秒，此时线程池所有线程应该是空闲的，下一次依然在线程10,11,12中执行3个任务，直到所有任务完成。 主线程id为1，子线程id为10,11,12因为线程池只设置了核心线程数为3，并且最大线程数也是3。 CacheThreadPool它是一种线程数量不固定的线程池，它只有非核心线程，并且虽大线程数为Integer.MAX_VALUE(一个很大的数)，相当于最大线程数可以任意大。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理新任务，否则就会利用空闲的线程来处理新任务。空闲线程有超时机制，60秒，超过60秒，回收空闲线程。从CacheThreadPool的特性可以知道，这类线程池适合执行大量耗时少的任务。当整个线程池都处于闲置状态时候，线程池中的线程都会因为超时而被回收，几乎不占用任何系统资源。 创建实例1ExecutorService cacheThreadPoolExecutor = Executors.newCachedThreadPool(); newCachedThreadPool()方法如下：123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 举个例子1234567891011121314151617181920212223private static void cacheThreadPoolTest()&#123; ExecutorService cacheThreadPoolExecutor = Executors.newCachedThreadPool(); for (int i=0; i&lt;10; i++)&#123; final int index = i; /* try &#123; Thread.sleep(1000); &#125;catch (InterruptedException itre)&#123; itre.printStackTrace(); &#125; */ cacheThreadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(System.currentTimeMillis() + &quot; &quot; + &quot;index = &quot; + index + &quot; &quot; + &quot;Thread id = &quot; + Thread.currentThread().getId()); &#125; &#125;); &#125;&#125; 运行情况：123456789101498985856125 index = 0 Thread id = 101498985856126 index = 1 Thread id = 111498985856126 index = 2 Thread id = 121498985856127 index = 3 Thread id = 131498985856127 index = 7 Thread id = 101498985856127 index = 6 Thread id = 141498985856127 index = 9 Thread id = 141498985856127 index = 4 Thread id = 121498985856127 index = 5 Thread id = 111498985856131 index = 8 Thread id = 15 可以看出，当线程池的所有线程活动的时候，线程池不断创建线程了执行新的任务 如果去掉线程等待的注释，再运行一次12345678910111213141516171819202122private static void cacheThreadPoolTest()&#123; ExecutorService cacheThreadPoolExecutor = Executors.newCachedThreadPool(); for (int i=0; i&lt;10; i++)&#123; final int index = i; try &#123; Thread.sleep(1000); &#125;catch (InterruptedException itre)&#123; itre.printStackTrace(); &#125; cacheThreadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(System.currentTimeMillis() + &quot; &quot; + &quot;index = &quot; + index + &quot; &quot; + &quot;Thread id = &quot; + Thread.currentThread().getId()); &#125; &#125;); &#125;&#125; 运行结果：123456789101112131498985981855 index = 0 Thread id = 10// 间隔一秒1498985982854 index = 1 Thread id = 10// 间隔一秒1498985983854 index = 2 Thread id = 10// 间隔一秒 下同省略了1498985984854 index = 3 Thread id = 101498985985855 index = 4 Thread id = 101498985986855 index = 5 Thread id = 101498985987855 index = 6 Thread id = 101498985988855 index = 7 Thread id = 101498985989855 index = 8 Thread id = 101498985990855 index = 9 Thread id = 10 可以看到，当等待的时候，活动线程已经执行完毕，变成闲置线程，由于等待时间少于60秒，闲置线程未被回收，因此始终在10号线程中执行。 ScheduledThreadPool它的核心线程数量是固定的，而非核心线程数没有限制，并且非核心线程闲置时会立即被回收。这类线程池主要用于执行定时任务或具有固定周期的重复任务 创建实例1ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4); newScheduledThreadPool()方法如下：1234567891011/** * Creates a thread pool that can schedule commands to run after a * given delay, or to execute periodically. * @param corePoolSize the number of threads to keep in the pool, * even if they are idle * @return a newly created scheduled thread pool * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; ScheduledThreadPoolExecutor()构造如下：123456789101112/** * Creates a new &#123;@code ScheduledThreadPoolExecutor&#125; with the * given core pool size. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 举个例子：1234567891011121314private static void scheduledThreadPoolTest()&#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Thread id = &quot; + Thread.currentThread().getId()); &#125; &#125;; ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4); //延时2s scheduledThreadPool.schedule(runnable,2, TimeUnit.SECONDS); //延迟1000ms后, 每隔500ms执行一次runnable scheduledThreadPool.scheduleAtFixedRate(runnable,1000, 500, TimeUnit.MILLISECONDS);&#125; SingleThreadExecutor这类线程池内部只有一个核心线程，它确保所有的任务都在同一线程中按顺序执行。SingleThreadExecutor的意义在于同一所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步问题。 创建实例1ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); newSingleThreadExecutor()方法如下：12345678910111213141516171819/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.) Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 举个例子123456789101112private static void singleThreadExecutorTest()&#123; ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i=0; i&lt;10; i++)&#123; final int index = i; singleThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;index = &quot; + index+ &quot; Thread id = &quot; + Thread.currentThread().getId()); &#125; &#125;); &#125;&#125; 运行结果：12345678910index = 0 Thread id = 10index = 1 Thread id = 10index = 2 Thread id = 10index = 3 Thread id = 10index = 4 Thread id = 10index = 5 Thread id = 10index = 6 Thread id = 10index = 7 Thread id = 10index = 8 Thread id = 10index = 9 Thread id = 10 可以看出，所有任务都在同一个线程中排队等待执行。","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"https://devallever.github.io/tags/ThreadPoolExecutor/"}]},{"title":"IntentService 工作原理","slug":"android-intent-service","date":"2017-07-02T01:22:13.000Z","updated":"2017-07-02T01:50:58.132Z","comments":true,"path":"2017/07/02/android-intent-service/","link":"","permalink":"https://devallever.github.io/2017/07/02/android-intent-service/","excerpt":"","text":"IntentService简介是一种特殊的Service，继承了Service并且是个抽象类，可用于执行后台耗时任务，当任务结束后自动停止，同时由于是服务的原因，它的优先级比普通线程高很多，因此不容易被系统杀死。在实现上，IntentService封装了HandlerThread和Handler。 基本流程startService(intentService):onCreate()-&gt;onStartCommand()-&gt;onStart()-&gt;sendMessage()-&gt;handlerMessage()-&gt;onHandlerIntent()-&gt;stopSelf(startId)-&gt;onDestroy-&gt; 详细解剖onCreate()当服务第一次创建的时候调用onCreate()12345678910111213@Overridepublic void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 该方法封装了HandlerThread 和 Handler onStartCommand()每一次启动服务的时候调用onStartCommand()12345@Overridepublic int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125; 该方法仅仅调用了onStart()方法 onStart()1234567@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; 该方法把startService传来的Intent和startId封装成Message消息，然后通过handler发送消息，接着执行mServiceHandler.handleMessage()其中ServiceHandler是IntentService的一个内部类，它的定义如下1234567891011private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125; handleMessage()12345@Overridepublic void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1);&#125; 该方法会执行onHandleIntent()方法，它是个抽象方法，因此我们自定义IntentService的时候必须重写onHandleIntent()方法。因为发送消息那那个handler是HandlerThread所关联的，所以处理信息的时候是在子线程进行的。不会的可以看看HandlerThread原理。 stopSelf()12345@Overridepublic void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1);&#125; 当onHandleIntent()方法执行完毕之后，会调用stopSelf(int)方法结束服务 onDestroy()1234@Overridepublic void onDestroy() &#123; mServiceLooper.quit();&#125; 最后销毁服务的时候，终止线程执行","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Thread","slug":"Thread","permalink":"https://devallever.github.io/tags/Thread/"},{"name":"IntentService","slug":"IntentService","permalink":"https://devallever.github.io/tags/IntentService/"},{"name":"Service","slug":"Service","permalink":"https://devallever.github.io/tags/Service/"}]},{"title":"HandlerThread简单使用","slug":"handler-thread-basic","date":"2017-07-01T08:59:50.000Z","updated":"2017-07-01T09:35:43.310Z","comments":true,"path":"2017/07/01/handler-thread-basic/","link":"","permalink":"https://devallever.github.io/2017/07/01/handler-thread-basic/","excerpt":"","text":"HandlerThread简介HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现就是在run()方法中通过Looper.prepare()创建消息队列，并通过Looper.loop()开启消息循环。这样在实际使用中就允许在HandlerThread中创建Handler了。由于HandlerThread的run()方法是一个无限循环，因此当明确不需要使用HandlerThread的时候可以通过Looper的quit()或quitSafely()来终止线程执行。 使用Handler通常我们会在主线程中创建Handler，在子线程中调用handler.post(runnable)传递消息到主线程的消息队列中处理runnable的run方法.这样完成了子线程到主线的切换。在onCreate()方法中1mainHandler = new Handler(); 然后在子线程中post12345678910111213btn_post_to_main_thread.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Log.d(TAG, &quot;Thread id = &quot; + Thread.currentThread().getId()); mainHandler.post(runnable); &#125; &#125;).start(); &#125;&#125;); runnable123456private Runnable runnable = new Runnable() &#123; @Override public void run() &#123; Log.d(TAG, &quot;Thread id = &quot; + Thread.currentThread().getId()); &#125;&#125;; 运行结果12HandlerThreadActivity: Thread id = 10383HandlerThreadActivity: Thread id = 1 使用HandlerThread先创建HandlerThread实例，在onCreate()方法中12handlerThread = new HandlerThread(&quot;handlerThread&quot;);handlerThread.start(); 这样就开启了一个带Looper的子线程，因为HandlerThread是继承自Thread，它的run方法是这样定义的123456789101112public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 关于Looper原理，可以参考《Android开发艺术探索》中的消息机制，我的理解是: Looper.prepare();创建Looper实例 Looper.loop();进入一个无限循环中，不断监听消息队列中是否有消息，有则把他取出来分发给handler的handlerMessage()中处理。 因为线程中需要有一个Looper，线程绑定的handler才可以发送消息到消息队列中，那么相应的线程才会得到处理。 然后就是利用handlerThread获取到Looper用来创建Handler实例1handler = new Handler(handlerThread.getLooper()); 此时这个handler即使实在主线程中创建，但是它与子线程的Looper关联了，所以处理消息时候也会在子线程中处理的123456btn_post_to_sub_thread.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; handler.post(runnable); &#125;&#125;); 运行结果：123HandlerThreadActivity: Thread id = 10382HandlerThreadActivity: Thread id = 10382HandlerThreadActivity: Thread id = 10382 可以知道是在子线程中处理的。 HandlerThread和Thread的区别 普通Thread主要用于在run()方法中执行一个耗时的任务 HandlerThread内部创建消息队列，需要handler消息方式来通知HandlerThread去执行一个具体的任务。","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Thread","slug":"Thread","permalink":"https://devallever.github.io/tags/Thread/"},{"name":"HandlerThread","slug":"HandlerThread","permalink":"https://devallever.github.io/tags/HandlerThread/"}]},{"title":"OkHttp的简单使用","slug":"okhttp-sample","date":"2017-06-30T12:07:13.000Z","updated":"2017-06-30T12:46:53.374Z","comments":true,"path":"2017/06/30/okhttp-sample/","link":"","permalink":"https://devallever.github.io/2017/06/30/okhttp-sample/","excerpt":"","text":"OkHttp简介关于Okhttp的简介，相信大家都不陌生了，这里就不讲了。 初级用法Get请求比如这里的使用get方法进行登录操作1234567891011121314private void doLoginGet()&#123; final String url = \"xxxxx?username=allever?password=123456\" OkHttpUtil.loginGet(url, new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, final Response response) throws IOException &#123; handleLogin(response.body().string();); &#125; &#125;);&#125; loginGet方法如下：1234567public static void loginGet(String url, Callback callback)&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); client.newCall(request).enqueue(callback);&#125; 是不是很简单，创建OkhttpClient实例，创建请求，然后执行请求，然后进行回调 处理结果1234567891011private void handleLogin(final String result)&#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Gson gson = new Gson(); LoginRoot loginRoot = gson.fromJson(result,LoginRoot.class); User user = loginRoot.getUser(); tv_result.setText(user.getNickname() + &quot;\\n&quot; + user.getSignature()); &#125; &#125;);&#125; 因为回调方法在子线程中，所以要切回到主线程中，方法有很多，可以使用Handler，这里直接runOnUiThread()就好了。简单起见，另外Gson处理json数据不在讨论范围之内， Post请求例子同上，登录操作12345678910111213private void doLoginPost()&#123; OkHttpUtil.loginPost(username, password, new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; handleLogin(response.body().string()); &#125; &#125;);&#125; 12345678910111213public static void loginPost(String username, String password, Callback callback)&#123; String url = BASE_URL + &quot;LoginServlet&quot;; OkHttpClient client = new OkHttpClient(); FormBody.Builder builder = new FormBody.Builder(); builder.add(&quot;username&quot;,username); RequestBody requestBody = builder.build(); Request request = new Request.Builder() .url(url) .post(requestBody) .build(); client.newCall(request).enqueue(callback);&#125; 唯一不同的就是这里啦，首先还是创建OkhttpClient实例，这里使用了FormBody表单, 用这个表单创建请求体，然后创建请求，最后执行请求，回调最后的处理方法同上。 异步请求上面两个例子都是异步请求，因为不用咋们手动开启子线程，它会自动的开启线程去处理的 同步请求例如，退出登录的例子123private void doLogoutTongBu()&#123; OkHttpUtil.logoutTongBu(handler); &#125; 123456789101112131415161718192021222324252627282930313233343536public static void logoutTongBu(final Handler handler)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; String url = \"xxxxx/logout\"; OkHttpClient client = new OkHttpClient(); FormBody.Builder builder = new FormBody.Builder(); if (!SharePreferenceUtil.getSessionId().equals(\"\"))&#123; RequestBody requestBody = builder.build(); Request request = new Request.Builder() .url(url) .post(requestBody) .addHeader(\"Cookie\", \"JSESSIONID=\" + SharePreferenceUtil.getSessionId()) .build(); Response response = null; try &#123; response = client.newCall(request).execute(); String result = response.body().string(); Message message = new Message(); message.what = MESSAGE_LOGOUT; message.obj = result; handler.sendMessage(message); &#125;catch (IOException ioe)&#123; ioe.printStackTrace(); &#125; &#125;else &#123; Message message = new Message(); message.what = MESSAGE_LOGOUT; message.obj = \"未登录\"; handler.sendMessage(message); &#125; &#125; &#125;).start();&#125; 这里手动开启了一个线程进行网络请求，还是使用Post方法，跟上面的没啥区别，注意这里1addHeader(&quot;Cookie&quot;, &quot;JSESSIONID=&quot; + SharePreferenceUtil.getSessionId()) 添加Cookie的头部信息，Cookie就是用来持久化用户登录还有就是执行请求的方法有些区别，同步执行是：1response = client.newCall(request).execute(); 异步执行是：1client.newCall(request).enqueue(callback); 同步执行的结果为Response对象，就是服务器返回的数据 高级用法上传文件和表单数据例如发一条说说，包括图片和文字12345678910111213private void doAddNews(String content)&#123; OkHttpUtil.addNews(content, new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(TAG, \"onResponse: result = \" + response.body().string()); &#125; &#125;);&#125; 12345678910111213141516171819202122232425public static void addNews(String content,Callback callback)&#123; OkHttpClient client = new OkHttpClient(); MultipartBody multipartBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(&quot;content&quot;,content) .addFormDataPart(&quot;city&quot;,&quot;番禺&quot;) .addFormDataPart(&quot;longitude&quot;,&quot;111.22&quot;) .addFormDataPart(&quot;latitude&quot;,&quot;22.22&quot;) .addPart(Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\\&quot;part1&quot;+ &quot;\\&quot;&quot;), RequestBody.create( MediaType.parse(&quot;application/octet-stream&quot;), new File(Environment.getExternalStorageDirectory().getPath()+&quot;/&quot;,&quot;jiaxin.png&quot;))) .build(); if (SharePreferenceUtil.getSessionId().equals(&quot;&quot;))&#123; &#125; Request request = new Request.Builder() .url(BASE_URL + &quot;AddNewsServlet&quot;) .post(multipartBody) .addHeader(&quot;Cookie&quot;, &quot;JSESSIONID=&quot; + SharePreferenceUtil.getSessionId()) .build(); client.newCall(request).enqueue(callback);&#125; 设置表单类型1setType(MultipartBody.FORM) 使用MultipartBody对象把表单数据和文件数据形式封装，表单使用1addFormDataPart(&quot;content&quot;,content) 用键值对保存 文件用12345.addPart(Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\\&quot;part1&quot;+ &quot;\\&quot;&quot;), RequestBody.create( MediaType.parse(&quot;application/octet-stream&quot;), fileObject)) 其中：part1是服务器根据键找到part的那个键1request.getPart(&quot;part1&quot;); 如果多文件的话就多次调用addPart() 必须设置表单类型 1setType(MultipartBody.FORM)","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Network","slug":"Network","permalink":"https://devallever.github.io/tags/Network/"},{"name":"OkHttp","slug":"OkHttp","permalink":"https://devallever.github.io/tags/OkHttp/"}]},{"title":"社交圈","slug":"social-app","date":"2017-06-21T13:17:26.000Z","updated":"2017-06-24T11:45:08.943Z","comments":true,"path":"2017/06/21/social-app/","link":"","permalink":"https://devallever.github.io/2017/06/21/social-app/","excerpt":"","text":"项目简介一款社交 APP附近人模块:中可以关注,聊天,加好友,好友分组管理。查找,筛选用户动态模块:可以,点赞,评论。可以发布语音动态,和语音评论并且实时通知。聊天模块,集成环信 IM。文本,表情,图片,位置,语音通话,视频聊天。设置在线状态,离开自动回复。推荐模块包括热点(浏览量最多的动态)、圈子(好友的动态)、定位(查看好友登录地理位置)通知模块:使用极光推送。刷新,发布动态,评论,点赞,好友请求。其他功能:查看关注用户,粉丝用户,谁看过我,照片墙。 项目架构 发现 用户 查看用户资料 查找用户 添加好友 删除好友 关注 聊天 动态 查看动态详细信息 发布动态 评论 点赞 聊天 消息列表 好友管理 分组管理：添加分组，删除分组，修改分组 修改好友备注，移动分组 推荐 热点：浏览量最多的动态 圈子：好友的动态 足迹(定位)：好友位置 我的 修改用户资料 修改在线状态 动态数，关注数，粉丝数 照片墙：添加照片，删除照片 访客：访问主页，访问动态 设置：视频聊天，清理缓存，自动回复 功能实现细节欢迎界面登录-注册刷刷主界面发现用户用户列表查找用户用户资料添加好友删除好友关注-粉丝数动态发布动态查看动态评论点赞查看大图聊天好友管理好友列表分组管理添加分组修改分组删除分组移动分组修改备注##推荐 热点圈子足迹(定位)排行榜我的修改用户资料修改在线状态照片墙访客动态数-关注数-粉丝数设置视频聊天清理缓存自动回复","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Project","slug":"Project","permalink":"https://devallever.github.io/tags/Project/"},{"name":"社交","slug":"社交","permalink":"https://devallever.github.io/tags/社交/"}]},{"title":"深入理解Java垃圾回收机制","slug":"java-gc","date":"2017-06-11T02:43:45.000Z","updated":"2017-06-15T05:26:47.239Z","comments":true,"path":"2017/06/11/java-gc/","link":"","permalink":"https://devallever.github.io/2017/06/11/java-gc/","excerpt":"","text":"垃圾回收机制的意义Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。 ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。 垃圾回收机制中的算法 Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情： （1）发现无用信息对象； （2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。 Jvm(Java虚拟机)内存模型在了解垃圾回收算法之前先简单了解一下jvm内存模型.从Jvm内存模型中入手对于理解GC会有很大的帮助，不过这里只需要了解一个大概，说多了反而混淆视线。 Jvm(Java虚拟机)主要管理两种类型内存：堆和非堆。 堆是运行时数据区域，所有类实例和数组的内存均从此处分配。 非堆是JVM留给自己用的，包含方法区、JVM内部处理或优化所需的内存（如 JIT Compiler，Just-in-time Compiler，即时编译后的代码缓存）、每个类结构（如运行时常数池、字段和方法数据）以及方法和构造方法的代码。 简言之，Java程序内存主要（这里强调主要二字）分两部分，堆和非堆。大家一般new的对象和数组都是在堆中的，而GC主要回收的内存也是这块堆内存。 配一张示意图总结一下： 堆内存（Heap Memory）： 存放Java对象非堆内存（Non-Heap Memory）： 存放类加载信息和其它meta-data其它（Other）： 存放JVM 自身代码等 重点是堆内存，我们就再看看堆的内存模型。 堆内存由垃圾回收器的自动内存管理系统回收。 堆内存分为两大部分：新生代和老年代。比例为1：2。 老年代主要存放应用程序中生命周期长的存活对象。 新生代又分为三个部分：一个Eden区和两个Survivor区，比例为8：1：1。 Eden区存放新生的对象。 Survivor存放每次垃圾回收后存活的对象。 其实只需要关注这几个问题: 为什么要分新生代和老年代？ 新生代为什么分一个Eden区和两个Survivor区? 一个Eden区和两个Survivor区的比例为什么是8:1:1？ 现在还不能解释为什么，但这几个问题都是垃圾回收机制所采用的算法决定的。所以问题转化为，是何种算法？为什么要采用此种算法？ 可回收对象的判定讲算法之前，我们先要搞清楚一个问题，什么样的对象是垃圾（无用对象），需要被回收？目前市面上有两种算法用来判定一个对象是否为垃圾。 引用计数算法 可达性分析算法（根搜索算法） 引用计数法(Reference Counting Collector)算法分析引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。 优缺点 优点: 简单，高效引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。 缺点: 无法检测出循环引用 如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0. 123456789101112public class Main &#123; public static void main(String[] args) &#123; MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); object1.object = object2; object2.object = object1; object1 = null; object2 = null; &#125;&#125; 最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。 可达性分析算法（根搜索算法）算法分析根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 java中可作为GC Root的对象有: 虚拟机栈中引用的对象（本地变量表） 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中引用的对象（Native对象） 优缺点 优点: 解决循环引用问题 缺点: Stop The World在学习GC前，你应该知道一个技术名词:这个词是“stop-the-world。“ 无论你选择哪种GC算法，Stop-the-world都会发生。Stop-the-world意味着JVM停止应用程序，而去进行垃圾回收。当stop-the-world发生时，除了进行垃圾回收的线程，其他所有线程都将停止运行。被中断的任务将在GC任务完成后恢复执行。GC调优往往意味着减少stop-the-world的时间. 垃圾回收的时候，需要整个的引用状态保持不变，否则判定是判定垃圾，等我稍后回收的时候它又被引用了，这就全乱套了。所以，GC的时候，其他所有的程序执行处于暂停状态，卡住了。 幸运的是，这个卡顿是非常短（尤其是新生代），对程序的影响微乎其微 （关于其他GC比如并发GC之类的，在此不讨论）。所以GC的卡顿问题由此而来，也是情有可原，暂时无可避免。 垃圾回收算法标记清除算法 (Mark-Sweep)原理分为两个阶段: 标记阶段(Mark) 和清除阶段(Sweep): 标记阶段: collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。 清除阶段: collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象-通过读取对象的header信息，则就将其回收。 collector指的就是垃圾收集器，而mutator是指除了垃圾收集器之外的部分，比如说我们应用程序本身。mutator的职责一般是NEW(分配内存),READ(从内存中读取内容),WRITE(将内容写入内存)，而collector则就是回收不再使用的内存来供mutator进行NEW操作的使用。mutator根对象一般指的是分配在堆内存之外，可以直接被mutator直接访问到的对象，一般是指静态/全局变量以及Thread-Local变量可达对象的定义，从mutator根对象开始进行遍历，可以被访问到的对象都称为是可达对象。这些对象也是mutator(你的应用程序)正在使用的对象。 优缺点 优点:简单,容易实现 缺点:容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。 复制算法 (Copying)原理复制算法将内存划分为两个区间,活动区和空闲区，在任意时间点，所有动态分配的对象都只能分配在活动区当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。 清理前: 清理后: 通俗的讲,就是: 复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。 优缺点 优点:实现简单，运行高效且不容易产生内存碎片 缺点:浪费内存 标记整理算法 (Mark-Compact)原理分为两个阶段: 标记阶段(Mark) 和整理阶段(Compact) 标记阶段: 与标记/清除算法是一模一样 整理阶段: 移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。 优缺点 优点: 标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价 缺点: 低效 分代回收算法(Generational Collector)分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的的特点综合而成。这种综合是考虑到java的语言特性的。这里重复一下两种老算法的适用场景： 复制算法：适用于存活对象很少。回收对象多 适用用于存活对象多，回收对象少 复习下面这个图: 解析： 堆内存分为两大部分：新生代和老年代。比例为1：2。 新生代又分为三个部分：一个Eden区和两个Survivor区，比例为8：1：1。 Eden区存放新生的对象。new Survivor存放每次垃圾回收后存活的对象。 老年代主要存放应用程序中生命周期长的存活对象。 原理(过程)所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 分配对象时，保存在Eden区 Eden区满，触发GC(Minor GC), 将Eden区存活对象复制到一个survivor0区，然后清空Eden区 当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区 此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收 年轻代 年老代 持久代 年轻代(Young Generation)： 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发) 年老代(Old Generation)： 年老代中存放的都是一些生命周期较长的对象。 老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。 持久代(Permanent Generation)： 用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。 深入理解分代回收算法为什么不是一块Survivor空间而是两块？这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历15次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次GC的时候，我们可以把Eden区的存活对象放到Survivor A空间，但是第二次GC的时候，Survivor A空间的存活对象也需要再次用Copying算法，放到Survivor B空间上，而把刚刚的Survivor A空间和Eden空间清除。第三次GC时，又把Survivor B空间的存活对象复制到Survivor A空间，如此反复。所以，这里就需要两块Survivor空间来回倒腾 为什么Eden空间这么大而Survivor空间要分的少一点？新创建的对象都是放在Eden空间，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到survivor空间的往往不多。所以，设置较大的Eden空间和较小的Survivor空间是合理的，大大提高了内存的使用率，缓解了Copying算法的缺点。我看8：1：1就挺好的，当然这个比例是可以调整的，包括上面的新生代和老年代的1：2的比例也是可以调整的。新的问题又来了，从Eden空间往Survivor空间转移的时候Survivor空间不够了怎么办？直接放到老年代去 垃圾收集器 新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge 老年代收集器使用的收集器：Serial Old、Parallel Old、CMS Serial收集器（复制算法) 新生代单线程收集器，标记和清理都是单线程，优点是简单高效。 Serial Old收集器(标记-整理算法) 老年代单线程收集器，Serial收集器的老年代版本。 ParNew收集器(停止-复制算法) 新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。Parallel Scavenge收集器(停止-复制算法)并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。 Parallel Old收集器(停止-复制算法) Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先 CMS(Concurrent Mark Sweep)收集器（标记-清理算法） 高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择 GC的执行机制Scavenge GC(Minor GC)一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。 Full GC对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC： 年老代（Tenured）被写满 持久代（Perm）被写满 System.gc()被显示调用 上一次GC之后Heap的各域分配策略动态变化 参考: 深入理解java垃圾回收机制理解Java垃圾回收机制","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"GC","slug":"GC","permalink":"https://devallever.github.io/tags/GC/"}]},{"title":"Adapter中的观察者模式","slug":"observer-adapter","date":"2017-06-02T01:02:15.000Z","updated":"2017-06-02T02:01:03.218Z","comments":true,"path":"2017/06/02/observer-adapter/","link":"","permalink":"https://devallever.github.io/2017/06/02/observer-adapter/","excerpt":"","text":"当我们调用Adapter.notifyDataSetChanged()时候, 会调用被观察者的()方法， 123456789101112131415161718192021222324252627public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter &#123; //数据集被观察者 private final DataSetObservable mDataSetObservable = new DataSetObservable(); public boolean hasStableIds() &#123; return false; &#125; public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer); &#125; public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer); &#125; /** * Notifies the attached observers that the underlying data has been changed * and any View reflecting the data set should refresh itself. */ public void notifyDataSetChanged() &#123; //通知观察者更新 mDataSetObservable.notifyChanged(); &#125; &#125; // 在DataSetObservable.notifyChanged()方法中，遍历每个观察者，并调用观察者的onChanged()方法。 123456789101112131415161718public class DataSetObservable extends Observable&lt;DataSetObserver&gt; &#123; /** * Invokes &#123;@link DataSetObserver#onChanged&#125; on each observer. * Called when the contents of the data set have changed. The recipient * will obtain the new contents the next time it queries the data set. */ public void notifyChanged() &#123; synchronized(mObservers) &#123; // since onChanged() is implemented by the app, it could do anything, including // removing itself from &#123;@link mObservers&#125; - and that could cause problems if // an iterator is used on the ArrayList &#123;@link mObservers&#125;. // to avoid such problems, just march thru the list in the reverse order. for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125; &#125;&#125; //这些观察者从哪里来的，又是什么时候绑定到DataSetObservable中的?查看ListView的setAdapter()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /** * Sets the data behind this ListView. * * The adapter passed to this method may be wrapped by a &#123;@link WrapperListAdapter&#125;, * depending on the ListView features currently in use. For instance, adding * headers and/or footers will cause the adapter to be wrapped. * * @param adapter The ListAdapter which is responsible for maintaining the * data backing this list and for producing a view to represent an * item in that data set. * * @see #getAdapter() */ @Override public void setAdapter(ListAdapter adapter) &#123; //如果已存在adapter先注销原来Adapter对应的观察者 if (mAdapter != null &amp;&amp; mDataSetObserver != null) &#123; mAdapter.unregisterDataSetObserver(mDataSetObserver); &#125; resetList(); mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) &#123; mAdapter = wrapHeaderListAdapterInternal(mHeaderViewInfos, mFooterViewInfos, adapter); &#125; else &#123; mAdapter = adapter; &#125; mOldSelectedPosition = INVALID_POSITION; mOldSelectedRowId = INVALID_ROW_ID; // AbsListView#setAdapter will update choice mode states. super.setAdapter(adapter); if (mAdapter != null) &#123; mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; mItemCount = mAdapter.getCount(); checkFocus();//创建一个数据集观察者 mDataSetObserver = new AdapterDataSetObserver(); //注册观察者 mAdapter.registerDataSetObserver(mDataSetObserver); mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; if (mStackFromBottom) &#123; position = lookForSelectablePosition(mItemCount - 1, false); &#125; else &#123; position = lookForSelectablePosition(0, true); &#125; setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) &#123; // Nothing selected checkSelectionChanged(); &#125; &#125; else &#123; mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); &#125; requestLayout(); &#125; ///AdapterDataSetObserver是AbsListView中定义的内部类123456789101112131415161718class AdapterDataSetObserver extends AdapterView&lt;ListAdapter&gt;.AdapterDataSetObserver &#123; @Override public void onChanged() &#123; //调用父类的onChange()方法。 super.onChanged(); if (mFastScroll != null) &#123; mFastScroll.onSectionsChanged(); &#125; &#125; @Override public void onInvalidated() &#123; super.onInvalidated(); if (mFastScroll != null) &#123; mFastScroll.onSectionsChanged(); &#125; &#125;&#125; 而它又继承AdapterView的AdapterDataSetObserver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 class AdapterDataSetObserver extends DataSetObserver &#123; private Parcelable mInstanceState = null;//最终调用 @Override public void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); requestLayout(); &#125; @Override public void onInvalidated() &#123; mDataChanged = true; if (AdapterView.this.getAdapter().hasStableIds()) &#123; // Remember the current state for the case where our hosting activity is being // stopped and later restarted mInstanceState = AdapterView.this.onSaveInstanceState(); &#125; // Data is invalid so we should reset our state mOldItemCount = mItemCount; mItemCount = 0; mSelectedPosition = INVALID_POSITION; mSelectedRowId = INVALID_ROW_ID; mNextSelectedPosition = INVALID_POSITION; mNextSelectedRowId = INVALID_ROW_ID; mNeedSync = false; checkFocus(); requestLayout(); &#125; public void clearSavedState() &#123; mInstanceState = null; &#125; &#125; 我们只关注onChanged()方法123456789101112131415161718@Overridepublic void onChanged() &#123; mDataChanged = true; mOldItemCount = mItemCount; mItemCount = getAdapter().getCount(); // Detect the case where a cursor that was previously invalidated has // been repopulated with new data. if (AdapterView.this.getAdapter().hasStableIds() &amp;&amp; mInstanceState != null &amp;&amp; mOldItemCount == 0 &amp;&amp; mItemCount &gt; 0) &#123; AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; &#125; else &#123; rememberSyncState(); &#125; checkFocus(); requestLayout();&#125; 它会调用requestLayout()方法进行重新布局，从而刷新listvew(GridView ， AdapterView)界面","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/categories/设计模式/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/tags/设计模式/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://devallever.github.io/tags/观察者模式/"}]},{"title":"设计模式(四) 抽象工厂模式","slug":"abstract-factory-patterns","date":"2017-05-25T01:03:48.000Z","updated":"2017-05-25T01:55:13.783Z","comments":true,"path":"2017/05/25/abstract-factory-patterns/","link":"","permalink":"https://devallever.github.io/2017/05/25/abstract-factory-patterns/","excerpt":"","text":"定义UML类图简单实现最基本的数据访问程序User表1234567891011121314151617181920public class User &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; SqlServerUser类1234567891011public class SqlServerUser &#123; private static final String TAG = &quot;SqlServerUser&quot;; public void insertUser(User user)&#123; Log.d(TAG, &quot;insert: 在SQL Server中录入一个用户记录&quot;); &#125; public User getUser(int id)&#123; Log.d(TAG, &quot;getUser: 在SQL Server中获取一个用户记录&quot;); return null; &#125;&#125; 客户端调用123456User user = new User();user.setId(1);user.setName(\"Allever\");SqlServerUser sqlServerUser = new SqlServerUser();sqlServerUser.insertUser(user);sqlServerUser.getUser(1); 如果换为MySQL数据库改动就很多 使用工厂方法改进IUser接口1234public interface IUser &#123; void insertUser(User user); User getUser(int id);&#125; SqlServerUser类1234567891011121314public class SqlServerUser implements IUser &#123; private static final String TAG = &quot;SqlServerUser&quot;; @Override public void insertUser(User user)&#123; Log.d(TAG, &quot;insert: 在SQL Server中录入一个用户记录&quot;); &#125; @Override public User getUser(int id)&#123; Log.d(TAG, &quot;getUser: 在SQL Server中获取一个用户记录&quot;); return null; &#125;&#125; MySQLUser类12345678910111213public class MySQLUser implements IUser &#123; private static final String TAG = &quot;MySQLUser&quot;; @Override public void insertUser(User user)&#123; Log.d(TAG, &quot;insert: 在MySQL Server中录入一个用户记录&quot;); &#125; @Override public User getUser(int id)&#123; Log.d(TAG, &quot;getUser: 在MySQL Server中获取一个用户记录&quot;); return null; &#125;&#125; IFactory抽象工厂接口123public interface IFactory &#123; IUser createUser();&#125; SqlServerFactory具体工厂类123456public class SqlServerFactory implements IFactory &#123; @Override public IUser createUser() &#123; return new SqlServerUser(); &#125;&#125; MySQLServerFactory具体工厂123456public class MySQLServerFactory implements IFactory &#123; @Override public IUser createUser() &#123; return new MySQLUser(); &#125;&#125; 客户端调用12345678User user = new User();user.setId(1);user.setName(&quot;Allever&quot;);IFactory factory = new SqlServerFactory();IUser iUser = factory.createUser();iUser.insertUser(user);iUser.getUser(1); 如果改为MySQL数据库，这改动这里1IFactory factory = new MySQLServerFactory(); 使用抽象工厂新增Department表1234567891011121314151617181920public class Department &#123; private int id; private String deptName; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getDeptName() &#123; return deptName; &#125; public void setDeptName(String deptName) &#123; this.deptName = deptName; &#125;&#125; 新增IDepartment接口1234public interface IDepartment &#123; void insertDepartment(Department department); Department getDepartment(int id);&#125; 新增SqlServerDepartment类12345678910111213public class SqlServerDepartment implements IDepartment &#123; private static final String TAG = &quot;SqlServerDepartment&quot;; @Override public void insertDepartment(Department department) &#123; Log.d(TAG, &quot;insertDepartment: 在Sql Server 中插入Department&quot;); &#125; @Override public Department getDepartment(int id) &#123; Log.d(TAG, &quot;insertDepartment: 在Sql Server 中获取Department&quot;); return null; &#125;&#125; 新增MySQLDepartment类12345678910111213public class MySQLDepartment implements IDepartment &#123; private static final String TAG = &quot;MySQLDepartment&quot;; @Override public void insertDepartment(Department department) &#123; Log.d(TAG, &quot;insertDepartment: 在MySQL 中插入Department&quot;); &#125; @Override public Department getDepartment(int id) &#123; Log.d(TAG, &quot;insertDepartment: 在MySQL 中获取Department&quot;); return null; &#125;&#125; 修改IFactory接口1234public interface IFactory &#123; IUser createUser(); IDepartment createDepartment(); //新增&#125; 修改SqlServerFactory类1234567891011public class SqlServerFactory implements IFactory &#123; @Override public IUser createUser() &#123; return new SqlServerUser(); &#125; @Override public IDepartment createDepartment() &#123; return new SqlServerDepartment(); &#125;&#125; 修改MySQLServerFactory类1234567891011public class MySQLServerFactory implements IFactory &#123; @Override public IUser createUser() &#123; return new MySQLUser(); &#125; @Override public IDepartment createDepartment() &#123; return new MySQLDepartment(); &#125;&#125; 客户端调用123456789101112131415User user = new User();user.setId(1);user.setName(&quot;Allever&quot;);Department department = new Department();department.setId(1);department.setDeptName(&quot;Computer&quot;);IFactory factory = new MySQLServerFactory();IUser iUser = factory.createUser();iUser.insertUser(user);iUser.getUser(1);IDepartment iDepartment = factory.createDepartment();iDepartment.insertDepartment(department);iDepartment.getDepartment(1); 总结只有一个User类和User操作类的时候，只需要工厂方法模式， 但现在数据库中有很多表， 而SQL Server 和 MySQL 又是两大不同的分类， 所以解决这种涉及到多个产品系列的时候，就要用到抽象工厂模式。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/tags/设计模式/"},{"name":"抽象工厂","slug":"抽象工厂","permalink":"https://devallever.github.io/tags/抽象工厂/"}]},{"title":"Android动画实例","slug":"animation-demo-1","date":"2017-05-24T06:54:12.000Z","updated":"2017-05-24T07:13:15.040Z","comments":true,"path":"2017/05/24/animation-demo-1/","link":"","permalink":"https://devallever.github.io/2017/05/24/animation-demo-1/","excerpt":"","text":"灵动菜单实现思路把菜单项目放在菜单按钮同一位置, 当点击带单按钮时候, 每个菜单项开始动画, 从原来位置,移动到指定位置 代码布局文件:1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/id_dynamic_activity_fab_left&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:layout_centerInParent=&quot;true&quot; android:visibility=&quot;visible&quot;/&gt; &lt;ImageView android:id=&quot;@+id/id_dynamic_activity_fab_top&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:layout_centerInParent=&quot;true&quot; android:visibility=&quot;visible&quot;/&gt; &lt;ImageView android:id=&quot;@+id/id_dynamic_activity_fab_right&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:layout_centerInParent=&quot;true&quot; android:visibility=&quot;visible&quot;/&gt; &lt;ImageView android:id=&quot;@+id/id_dynamic_activity_fab_bottom&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot; android:layout_centerInParent=&quot;true&quot; android:visibility=&quot;visible&quot;/&gt; &lt;ImageView android:id=&quot;@+id/id_dynamic_activity_fab_main&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@mipmap/ic_launcher&quot; android:layout_centerInParent=&quot;true&quot;/&gt;&lt;/RelativeLayout&gt; 展开菜单:123456789101112131415161718192021222324private void startMenu()&#123; ObjectAnimator mainAnimator = ObjectAnimator.ofFloat(ivMain,\"alpha\",1f,0.5f); float leftCurrentX = ivLeft.getTranslationX(); ObjectAnimator leftAnimator = ObjectAnimator.ofFloat(ivLeft,\"translationX\",leftCurrentX,-200f); float rightCurrentX = ivRight.getTranslationX(); ObjectAnimator rightAnimator = ObjectAnimator.ofFloat(ivRight,\"translationX\",rightCurrentX,200f); float topCurrentY = ivTop.getTranslationY(); ObjectAnimator topAnimator = ObjectAnimator.ofFloat(ivTop,\"translationY\",topCurrentY,-200f); float bottomCurrentY = ivBottom.getTranslationY(); ObjectAnimator bottomAnimator = ObjectAnimator.ofFloat(ivBottom,\"translationY\",bottomCurrentY,200f); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether(mainAnimator,leftAnimator,rightAnimator,topAnimator,bottomAnimator); animatorSet.setDuration(500); animatorSet.setInterpolator(new BounceInterpolator()); animatorSet.start(); flag = false;&#125; 关闭菜单:123456789101112131415161718192021222324private void closeMenu()&#123; ObjectAnimator mainAnimator = ObjectAnimator.ofFloat(ivMain,\"alpha\",0.5f,1f); float leftCurrentX = ivLeft.getTranslationX(); ObjectAnimator leftAnimator = ObjectAnimator.ofFloat(ivLeft,\"translationX\",leftCurrentX, 0f); float rightCurrentX = ivRight.getTranslationX(); ObjectAnimator rightAnimator = ObjectAnimator.ofFloat(ivRight,\"translationX\",rightCurrentX,0f); float topCurrentY = ivTop.getTranslationY(); ObjectAnimator topAnimator = ObjectAnimator.ofFloat(ivTop,\"translationY\",topCurrentY,0f); float bottomCurrentY = ivBottom.getTranslationY(); ObjectAnimator bottomAnimator = ObjectAnimator.ofFloat(ivBottom,\"translationY\",bottomCurrentY,0f); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether(mainAnimator,leftAnimator,rightAnimator,topAnimator,bottomAnimator); animatorSet.setDuration(500); animatorSet.setInterpolator(new BounceInterpolator()); animatorSet.start(); flag = true;&#125; 对主菜单按钮监听1234567ivMain.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (flag) startMenu(); else closeMenu(); &#125;&#125;); 下拉展开动画实现思路两个LinearLayout, 一个visibility为显示,另一个为gone. 当点击showVIew时,把隐藏的LinearLayout设置为visibility,对这个过程使用动画. 代码布局文件:123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/id_show_hide_ll_show_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;click me&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=&quot;@+id/id_show_hide_ll_hide_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:gravity=&quot;center_vertical&quot; android:visibility=&quot;gone&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;I am hide&quot;/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 获取ValueAnimator:12345678910111213private ValueAnimator createValueAnimator(final View view, int start, int end)&#123; final ValueAnimator animator = ValueAnimator.ofInt(start,end); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; int value = (int)valueAnimator.getAnimatedValue(); ViewGroup.LayoutParams params = view.getLayoutParams(); params.height = value; view.setLayoutParams(params); &#125; &#125;); return animator;&#125; 展开动画:12345private void openAnimation(View view)&#123; view.setVisibility(View.VISIBLE); ValueAnimator valueAnimator = createValueAnimator(view,0,measureHiddenViewHeight); valueAnimator.start();&#125; 关闭动画:1234567891011private void closeAnimation(final View view) &#123; int origHeight = view.getHeight(); ValueAnimator valueAnimator = createValueAnimator(view,origHeight,0); valueAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; view.setVisibility(View.GONE); &#125; &#125;); valueAnimator.start();&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"动画","slug":"动画","permalink":"https://devallever.github.io/tags/动画/"}]},{"title":"设计模式(三) 工厂方法模式","slug":"factory-method-patterns","date":"2017-05-24T03:51:32.000Z","updated":"2017-05-24T04:20:19.029Z","comments":true,"path":"2017/05/24/factory-method-patterns/","link":"","permalink":"https://devallever.github.io/2017/05/24/factory-method-patterns/","excerpt":"","text":"定义定义一个用于创建对象的接口,让子类决定实例化那个类 UML类图 解读: Product: 产品抽象类, ConcreteProduct: 产品实现类 Creator: 工厂抽象类, 返回一个Product实例 ConcreteCreator: 工厂实现类, 返回一个ConcreteProduct实例 简单实现## Fruit: 作为产品抽象类123public abstract class Fruit &#123; abstract void getName();&#125; ## Banana: 作为产品实现类123456public class Banana extends Fruit &#123; @Override void getName() &#123; System.out.println(\"I am banana\"); &#125;&#125; Apple: 作为产品实现类123456public class Apple extends Fruit &#123; @Override void getName() &#123; System.out.println(\"I am apple\"); &#125;&#125; FruitFactory: 作为抽象工厂类123public abstract class FruitFactory &#123; abstract Fruit createFruit();&#125; AppleFactory: 作为工厂实现类123456public class AppleFactory extends FruitFactory &#123; @Override Fruit createFruit() &#123; return new Apple(); &#125;&#125; BananaFactory: 作为工厂实现类123456public class BananaFactory extends FruitFactory &#123; @Override Fruit createFruit() &#123; return new Banana(); &#125;&#125; 使用在需要哪一个产品时就生产哪个123FruitFactory fruitFactory = new AppleFactory();Fruit apple = fruitFactory.createFruit();apple.getName(); 使用反射FruitFactory123public abstract class FruitFactory &#123; abstract &lt;T extends Fruit&gt; T createFruit(Class&lt;T&gt; className);&#125; ### ConcreteFruitFactory: 具体工厂类123456789101112public class ConcreteFruitFactory extends FruitFactory &#123; @Override &lt;T extends Fruit&gt; T createFruit(Class&lt;T&gt; className) &#123; Fruit fruit = null; try &#123; fruit = (Fruit)Class.forName(className.getName()).newInstance(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return (T)fruit; &#125;&#125; 使用需要哪个类对象就传入那个类的类型123FruitFactory fruitFactory = new ConcreteFruitFactory();Fruit apple = fruitFactory.createFruit(Apple.class);apple.getName(); 简单工厂方法模式当工厂只有一个的时候, 只需将对应的工厂方法改为静态方法, 并去掉abstract关键字, 此时就变成了简单工厂模式或者静态工厂模式12345public class FruitFactory &#123; static Fruit createFruit()&#123; return new Apple(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/tags/设计模式/"},{"name":"工厂方法模式","slug":"工厂方法模式","permalink":"https://devallever.github.io/tags/工厂方法模式/"}]},{"title":"Android练手项目 极简天气","slug":"myCoolWeather","date":"2017-05-23T12:55:18.000Z","updated":"2017-05-23T13:41:25.138Z","comments":true,"path":"2017/05/23/myCoolWeather/","link":"","permalink":"https://devallever.github.io/2017/05/23/myCoolWeather/","excerpt":"","text":"项目地址: https://github.com/devallever/MyCoolWeather 下载apk 我的博客: https://devallever.github.io/ 简介极简天气, 天气应用,是我看完Android第一行代码后, 参考并修改的练习项目, 以巩固所学知识 感谢开源 OkHttp Retrofit Glide RxJava/RxAndroid LitePal EventBus 感谢郭神提供天气数据接口 功能第一版 显示实时天气, 三天预报, 空气质量, 温馨提示 获取Bing每日图片 滑动切换城市 城市管理: 增加,删除 下拉刷新 缓存省市县, 天气信息 第二版 后台自动刷新 自动下载壁纸 天气提醒 查看历史天气 关于 设置刷新频，全局提醒，背景图片 检查更新 功能实现细节第二版功能细节后台自动更新天气信息使用服务, 启动服务后通过AlarmManager设置一个定时任务,每隔一小时更新天气信息, 在退出程序时候启动该服务,在服务中主要执行了两个方法分别更新天气信息和壁纸, 请求网络后把数据保存到Weather表中12345678910111213141516@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, &quot;onStartCommand: ()&quot;); updateWeather(); updateImage(); int anHour = 1 * 60 * 60 * 1000; //１小时 //int anHour = 10* 1000; //10秒 long triggerAtTime = SystemClock.elapsedRealtime() + anHour; AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE); Intent serviceIntent = new Intent(this, AutoUpdateService.class); //Intent receiverIntent = new Intent(this, AutoUpdateReceiver.class); PendingIntent pendingIntent = PendingIntent.getService(this,0,serviceIntent,0); alarmManager.cancel(pendingIntent); alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime,pendingIntent); return super.onStartCommand(intent, flags, startId);&#125; 启动服务1234567@Overrideprotected void onDestroy() &#123; //启动后台更新服务 Intent serviceIntent = new Intent(this, AutoUpdateService.class); startService(serviceIntent); super.onDestroy();&#125; 天气提醒功能每次后台获取更新后,判断该城市是否显示通知, 是的话就对天气信息进一步分析: 昼夜温度大于10度时提醒,1234567int max = Integer.valueOf(newWeather.getDaily_forecast().get(0).getTmp().getMax());int min = Integer.valueOf(newWeather.getDaily_forecast().get(0).getTmp().getMin());if ((max-min) &gt;=10 )&#123;//显示通知builder.setContentText( county + &quot;: 昼夜温差较大,请预防感冒!&quot;);notificationManager.notify(id,builder.build());&#125; 今明天气相差5度时提醒12345678910111213//2.比较今天明天气温相差5度提示Daily_forecast today = newWeather.getDaily_forecast().get(0);Daily_forecast tomorrow = newWeather.getDaily_forecast().get(1);int todayTmp = Integer.valueOf(today.getTmp().getMin());int tomorrowTmp = Integer.valueOf(tomorrow.getTmp().getMin());if ( Math.abs(todayTmp-tomorrowTmp) &gt;= 5)&#123; if (tomorrowTmp &gt; todayTmp)&#123; builder.setContentText( county + &quot;: 明天将大幅度升温!&quot;); &#125;else &#123; builder.setContentText( county + &quot;: 明天将大幅度降温温!&quot;); &#125;notificationManager.notify(id+1000,builder.build());&#125; 有降水提示带伞12345//3. 有雨的要带伞if (tomorrow.getCond().getTxt_d().contains(&quot;雨&quot;))&#123; builder.setContentText( county + &quot;: 明天将有&quot; + tomorrow.getCond().getTxt_d() + &quot;, 出门记得带伞.&quot;); notificationManager.notify(id+1001,builder.build());&#125; 当实时天气与上一次的天气有不同时候,提醒1234567//4. 比较实时天气String old = oldWeather.getNow().getCond().getTxt();String newInfo = newWeather.getNow().getCond().getTxt();if (!old.equals(newInfo))&#123; builder.setContentText( county + &quot;: &quot; + newWeather.getNow().getCond().getTxt()); notificationManager.notify(id+1002,builder.build());&#125; 查看历史天气创建一个数据库表HistoryWeather用来保存历史天气信息id, weatherId, countyName, date, weatehr, min, max每次后台自动更新天气数据时候，解析json数据，获取所需数据封装成HIstoryWeather，然后保存，根据date和weatherId字段获取要保存的记录，如果存在的就更新，不存在的就天机记录123456789101112131415161718192021222324private void saveHistoryWeather(String result)&#123; Gson gson = new Gson(); HeWeather5 heWeather5 = gson.fromJson(result,Root.class).getHeWeather5().get(0); List&lt;Daily_forecast&gt; daily_forecastList = heWeather5.getDaily_forecast(); //for (Daily_forecast daily_forecast :daily_forecastList)&#123; Daily_forecast today = daily_forecastList.get(0); String date = today.getDate(); String weather = today.getCond().getTxt_d(); String weatherId = heWeather5.getBasic().getId(); String countyName = heWeather5.getBasic().getCity(); String min = today.getTmp().getMin(); String max = today.getTmp().getMax(); HistoryWeather historyWeather = new HistoryWeather(); historyWeather.setDate(date); historyWeather.setWeatherId(weatherId); historyWeather.setCountyName(countyName); historyWeather.setWeather(weather); historyWeather.setMin(min); historyWeather.setMax(max); historyWeather.saveOrUpdate(&quot;weatherId=? and date=?&quot;, weatherId, date); //&#125;&#125; 查找历史天气信息时候，默认是查找前30条记录，并且按date降序排列12345678910List&lt;HistoryWeather&gt; historyWeatherList;historyWeatherList = DataSupport.where(&quot;weatherId=? order by date desc&quot;, weatherId).find(HistoryWeather.class);for (HistoryWeather historyWeather: historyWeatherList)&#123; HistoryWeatherItem historyWeatherItem = new HistoryWeatherItem(); historyWeatherItem.setWeather(historyWeather.getWeather()); historyWeatherItem.setDate(historyWeather.getDate()); historyWeatherItem.setMax(historyWeather.getMax()); historyWeatherItem.setMin(historyWeather.getMin()); historyWeatherItemList.add(historyWeatherItem);&#125; 第一版功能细节选择城市 ChooseCItyActivity首先访问数据库中是否有所有省份数据,有则获取,没有则请求服务器,然后得到全国省份的json数据,保存到数据库中12345678910111213141516private void queryProvince()&#123; toolbar.setTitle(&quot;中国&quot;); provinceList = DataSupport.findAll(Province.class); if (provinceList.size() &gt; 0)&#123; dataList.clear(); for (Province province:provinceList)&#123; dataList.add(province.getProvinceName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_PROVINCE; &#125;else &#123; String address = &quot;http://guolin.tech/api/china/&quot;; queryFromServer(address, &quot;province&quot;); &#125;&#125; 123456789101112131415161718public static boolean handleProvinceResponse(String response)&#123; if (!TextUtils.isEmpty(response))&#123; try &#123; JSONArray allProvince = new JSONArray(response); for (int i = 0; i&lt;allProvince.length(); i++)&#123; JSONObject provinceObject = allProvince.getJSONObject(i); Province province = new Province(); province.setProvinceCode(provinceObject.getInt(&quot;id&quot;)); province.setProvinceName(provinceObject.getString(&quot;name&quot;)); province.save(); &#125; return true; &#125;catch (JSONException je)&#123; je.printStackTrace(); &#125; &#125; return false;&#125; 然后解析json数据,设置到Listview中,点击时记录省份id, 然后根据这个id访问数据库中是否有该省份的城市信息,有则获取,没有则请求服务器,然后得到该省份所有城市的json数据,保存到数据库中 1234567891011121314151617private void queryCity()&#123; toolbar.setTitle(selectedProvince.getProvinceName()); cityList = DataSupport.where(&quot;provinceCode = ? &quot;, String.valueOf(selectedProvince.getProvinceCode())).find(City.class); if (cityList.size() &gt; 0)&#123; dataList.clear(); for (City city: cityList)&#123; dataList.add(city.getCityName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_CITY; &#125;else &#123; int provinceCode = selectedProvince.getProvinceCode(); String address = &quot;http://guolin.tech/api/china/&quot; + provinceCode; queryFromServer(address,&quot;city&quot;); &#125;&#125; 1234567891011121314151617181920public static boolean handleCityResponse(String response, int provinceCode)&#123; if (!TextUtils.isEmpty(response))&#123; try &#123; Log.d(TAG, &quot;handleCityResponse: \\n response = &quot; + response); JSONArray allCity = new JSONArray(response); for (int i = 0; i&lt; allCity.length(); i++)&#123; JSONObject cityObject = allCity.getJSONObject(i); City city = new City(); city.setCityCode(cityObject.getInt(&quot;id&quot;)); city.setCityName(cityObject.getString(&quot;name&quot;)); city.setProvinceCode(provinceCode); city.save(); &#125; return true; &#125;catch (JSONException je)&#123; je.printStackTrace(); &#125; &#125; return false;&#125; 然后解析json数据,清空listview数据源, 然后加载该省的所有城市数据,设置到ListView中,点击时记录该市的id, 然后根据这个id访问数据库中是否存在该市的所有县数据,有则获取, 没有则请求服务器,然后得到该市所有县的json数据,保存到数据库中 1234567891011121314151617181920private void queryCounty()&#123; toolbar.setTitle(selectedCity.getCityName()); Toast.makeText(this,&quot;cityCode = &quot;+ selectedCity.getCityCode() + &quot;\\n&quot; + &quot;id = &quot; + selectedCity.getId(),Toast.LENGTH_LONG ).show(); countyList = DataSupport.where(&quot;cityCode = ?&quot;, String.valueOf(selectedCity.getId())).find(County.class); if (countyList.size() &gt; 0 )&#123; dataList.clear(); for (County county: countyList)&#123; dataList.add(county.getCountyName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_COUNTY; &#125;else &#123; int provinceCode = selectedProvince.getProvinceCode(); int cityCode = selectedCity.getCityCode(); String address = &quot;http://guolin.tech/api/china/&quot; + provinceCode + &quot;/&quot; + cityCode; queryFromServer(address,&quot;county&quot;); &#125;&#125; 123456789101112131415161718192021public static boolean handleCountyResponse(String response, int cityCode)&#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allCounty = new JSONArray(response); for (int i = 0; i &lt; allCounty.length(); i++) &#123; JSONObject countyObject = allCounty.getJSONObject(i); County county = new County(); county.setCountyName(countyObject.getString(&quot;name&quot;)); county.setWeatherId(countyObject.getString(&quot;weather_id&quot;)); county.setCityCode(cityCode); boolean successed = county.save(); if (successed) Log.d(TAG, &quot;handleCountyResponse: save success&quot;); else Log.d(TAG, &quot;handleCountyResponse: save fail&quot;); &#125; return true; &#125; catch (JSONException je) &#123; je.printStackTrace(); &#125; &#125; return false;&#125; 选择其中某一项, 获取weatherId和县名称countyName, 通过setResult返回父Activity中,在父Activity中onActivityResult方法中, 把weatherId和countyName保存到Weather数据表中, 然后重新获取weather表中数据. 1234567891011121314151617181920212223242526listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; if (currentLevel == LEVEL_PROVINCE)&#123; selectedProvince = provinceList.get(position); queryCity(); &#125;else if (currentLevel == LEVEL_CITY)&#123; selectedCity = cityList.get(position); Toast.makeText(ChooseCityActivity.this,&quot;id = &quot; + selectedCity.getId() + &quot;\\n&quot;+ &quot;cityName = &quot; + selectedCity.getCityName() + &quot;\\n&quot; + &quot;cityCode = &quot; + selectedCity.getCityCode() + &quot;\\n&quot; + &quot;provinceCode = &quot; + selectedCity.getProvinceCode(),Toast.LENGTH_SHORT).show(); queryCounty(); &#125;else if (currentLevel == LEVEL_COUNTY)&#123; selectedCounty = countyList.get(position); Toast.makeText(ChooseCityActivity.this,&quot;id = &quot; + selectedCounty.getId() + &quot;\\n&quot;+ &quot;countyName = &quot; + selectedCounty.getCountyName() + &quot;\\n&quot; + &quot;weather_id = &quot; + selectedCounty.getWeatherId(),Toast.LENGTH_SHORT).show(); Intent intent = new Intent(); intent.putExtra(&quot;weather_id&quot;, selectedCounty.getWeatherId()); intent.putExtra(&quot;county_name&quot;,selectedCounty.getCountyName()); setResult(RESULT_OK,intent); finish(); &#125; &#125;&#125;); 回到父Activity进行操作12345678910111213String weather_id = data.getStringExtra(&quot;weather_id&quot;);List&lt;Weather&gt; weatherList = DataSupport.where(&quot;weatherId = ? &quot;, weather_id).find(Weather.class);if (weatherList != null &amp;&amp; weatherList.size()==0)&#123; Weather weather = new Weather(); weather.setCountyName(data.getStringExtra(&quot;county_name&quot;)); weather.setWeatherId(data.getStringExtra(&quot;weather_id&quot;)); weather.setIsShow(&quot;1&quot;); weather.save(); titleList.add(weather.getCountyName()); WeatherFragment weatherFragment = new WeatherFragment(weather.getWeatherId()); weatherFragmentList.add(weatherFragment); weatherPageAdapter.notifyDataSetChanged();&#125; 构造ViewPager天气页面数据源在MainActivity中,访问数据库weather表, (条件:isShow=1,表示显示是否显示在主界面), 把查询结果存到List中,如果list大小为0, 则打开选择城市界面,如果存在数据,则遍历每个weather对象,创建WeatherFragment,并把weather对象中的weatherId传到Fragment的构造方法中,并添加到fragmengList中, WeatherFragment会根据这个weatherId获取天气信息,同时把weather的countyName添加到titleLists中用于设置每个pager的标题,,,然后通知adapter数据更新了,pagerAdapter是通过fragmengList和titleList绑定数据的 123456789101112131415161718private void showWeather()&#123; weatherList.clear(); weatherFragmentList.clear(); titleList.clear(); weatherList = DataSupport.where(&quot;isShow=?&quot;, &quot;1&quot;).find(Weather.class); if (weatherList.size() ==0)&#123; //转到选择城市Activity Intent intent = new Intent(this, ChooseCityActivity.class); startActivityForResult(intent, REQUEST_CODE_CHOOSE_CITY); &#125;else &#123; for (Weather weather: weatherList) &#123; titleList.add(weather.getCountyName()); WeatherFragment weatherFragment = new WeatherFragment(weather.getWeatherId()); weatherFragmentList.add(weatherFragment); &#125; weatherPageAdapter.notifyDataSetChanged(); &#125;&#125; 选择城市后返回的操作12345678910111213String weather_id = data.getStringExtra(&quot;weather_id&quot;);List&lt;Weather&gt; weatherList = DataSupport.where(&quot;weatherId = ? &quot;, weather_id).find(Weather.class);if (weatherList != null &amp;&amp; weatherList.size()==0)&#123; Weather weather = new Weather(); weather.setCountyName(data.getStringExtra(&quot;county_name&quot;)); weather.setWeatherId(data.getStringExtra(&quot;weather_id&quot;)); weather.setIsShow(&quot;1&quot;); weather.save(); titleList.add(weather.getCountyName()); WeatherFragment weatherFragment = new WeatherFragment(weather.getWeatherId()); weatherFragmentList.add(weatherFragment); weatherPageAdapter.notifyDataSetChanged();&#125; 城市管理-CityManageActivity该页面有一个RecyclerView,和一个FloatingActionButton, 其中recyclerView的item是一个CardView, 显示了该城市粗略的天气信息,如温度和天气,fab用于添加城市,可以通过左右滑动每一个卡片来删除数据,请求数据库, 访问weather表的所有数据, 抽取其中所需的信息封装到CityItem中,然后添加到cityItemList中,作为RecyclerView的数据源,当成功选择一个城市并返回后,根据返回的weatherId访问数据库是否存在该数据,有则不操作,没有则添加到weather表中.以免产生冗余数据.当滑动删除城市后,会从数据表中删除掉这条记录,(改进的做法是滑动删除后显示一个Snackbar来确认操作)12345678910111213141516weatherList = DataSupport.findAll(Weather.class);Gson gson = new Gson();Root root;for (Weather weather: weatherList)&#123; CityItem cityItem = new CityItem(); cityItem.setIsShow(weather.getIsShow()); root = gson.fromJson(weather.getWeatherInfo(),Root.class); if (root!=null)&#123; cityItem.setTmp(root.getHeWeather5().get(0).getNow().getTmp()); cityItem.setWeather(root.getHeWeather5().get(0).getNow().getCond().getTxt()); cityItem.setCounty(weather.getCountyName()); cityItem.setWeatherId(weather.getWeatherId()); cityItemList.add(cityItem); &#125;&#125;cityRecyclerAdapter.notifyDataSetChanged(); 滑动删除后的操作-我还在进一步研究,不是很懂,因为是复制别人的代码关联1234//关联ItemTouchHelper和RecyclerViewItemTouchHelper.Callback callback = new ItemTouchHelperCallback(cityRecyclerAdapter);ItemTouchHelper mItemTouchHelper = new ItemTouchHelper(callback);mItemTouchHelper.attachToRecyclerView(recyclerView); ItemTouchHelperCallback:1234567891011121314151617181920212223242526272829303132333435363738394041public class ItemTouchHelperCallback extends ItemTouchHelper.Callback &#123; private OnMoveAndSwipedListener moveAndSwipedListener; public ItemTouchHelperCallback(OnMoveAndSwipedListener listener) &#123; this.moveAndSwipedListener = listener; &#125; //设置拖动方向以及侧滑方向 @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; if (recyclerView.getLayoutManager() instanceof LinearLayoutManager) &#123; //单列的RecyclerView支持上下拖动和左右侧滑 final int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; final int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END; return makeMovementFlags(dragFlags, swipeFlags); &#125; else &#123; //多列的RecyclerView支持上下左右拖动和不支持左右侧滑 final int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; final int swipeFlags = 0; return makeMovementFlags(dragFlags, swipeFlags); &#125; &#125; //拖动item时会调用此方法 @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; //如果两个item不是同一个类型的，不让他拖拽 if (viewHolder.getItemViewType() != target.getItemViewType()) &#123; return false; &#125; moveAndSwipedListener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition()); return true; &#125; //侧滑item时会调用此方法 @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; moveAndSwipedListener.onItemDismiss(viewHolder.getAdapterPosition()); &#125;&#125; OnMoveAndSwipedListener:1234567public interface OnMoveAndSwipedListener &#123; boolean onItemMove(int fromPosition, int toPosition); void onItemDismiss(int position);&#125; 监听到滑动删除执行以下方法123456789101112@Overridepublic boolean onItemMove(int fromPosition, int toPosition) &#123; notifyItemMoved(fromPosition, toPosition); return true;&#125;@Overridepublic void onItemDismiss(int position) &#123; DataSupport.deleteAll(Weather.class,&quot;weatherId=?&quot;,cityItemList.get(position).getWeatherId()); cityItemList.remove(position); notifyItemRemoved(position);&#125; 显示天气-WeatherFragmeng显示天气信息是在WeatherFragment中完成的, 也就是每个页面. 从构造方法中获取到该所显示城市的天气数据, 根据这个weatherId访问数据库中该weatherId所在记录是否有weatherInfo信息,如果有则获取该天气信息的json数据, 没有则向服务器请求数据,获取天气信息,成功获取信息之后保存到数据库中. 12345678weatherList = DataSupport.where(\"weatherId = ? \", weather_id).find(Weather.class);if (weatherList != null &amp;&amp; weatherList.size()&gt;0)&#123; if (TextUtils.isEmpty(weatherList.get(0).getWeatherInfo())) sendWeatherInfoRequest(); else handleWeatherInfoResponse(weatherList.get(0).getWeatherInfo());&#125;else &#123; //get dada from internet sendWeatherInfoRequest();&#125; 获取后保存到数据库12345678910String responseText = response.body().string();Weather weather = new Weather();weather.setWeatherInfo(responseText);weather.updateAll(\"weatherId=?\", weather_id);getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; handleWeatherInfoResponse(responseText); &#125;&#125;); 持续更新……..欢迎大家共同学习共同成长…..","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Project","slug":"Project","permalink":"https://devallever.github.io/tags/Project/"}]},{"title":"排序算法","slug":"algorithms-sort","date":"2017-05-23T12:54:18.000Z","updated":"2017-06-25T13:25:04.244Z","comments":true,"path":"2017/05/23/algorithms-sort/","link":"","permalink":"https://devallever.github.io/2017/05/23/algorithms-sort/","excerpt":"","text":"冒泡排序思想比较相邻记录关键字，如果逆序，则进行交换，从而使记录小的像气泡一样逐渐往上“漂浮”(左移)，或者说使记录大的像石头那样”下沉”(右移) 算法实现java实现原序列1int a[10] = &#123;4,3,2,6,1,9,5,8,7,0&#125;; 12345678910111213141516171819202122232425262728293031private static void popSort(int[] a)&#123; //最基本的冒泡排序写法 /*int i; for (i=0;i&lt;a.length;i++)&#123; for (int j=0;j&lt;a.length-1;j++)&#123; if (a[j]&gt;a[j+1])&#123; int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125;*/ //改进的冒泡排序写法 int len = a.length-1; boolean flag = true;//用来标识是否发生交换操作 while (len&gt;0 &amp;&amp; flag)&#123; flag = false; for (int j=0;j&lt;len;j++)&#123; if (a[j] &gt; a[j+1])&#123; //交换 int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; flag = true; &#125; &#125; show(a); len--; &#125;&#125; 运行结果1234567891011原序列: 1 6 5 9 3 8 2 7 0 4 1 5 6 3 8 2 7 0 4 9 1 5 3 6 2 7 0 4 8 9 1 3 5 2 6 0 4 7 8 9 1 3 2 5 0 4 6 7 8 9 1 2 3 0 4 5 6 7 8 9 1 2 0 3 4 5 6 7 8 9 1 0 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 排序后: 0 1 2 3 4 5 6 7 8 9 快速排序(冒泡排序升级版)思想在待排记录中选择一个记录(通常第一个)作为枢纽(关键记录)pivotkey. 经过一趟排序，以枢纽记录分为两个子表，左边子表记录比枢纽记录小，右边子表比枢纽记录大。然后对每个子表重复以上过程。知道每个子表只有一个记录时，排序结束。 每一趟操做 参考《大话数据结构》有详细解析 选择表中一个记录作为枢纽(通常是第一个记录) 保存好记录的值pivotkey (1)从high往左每个记录依次与pivotkey比较，比pivotkey大或相等的，high往左移(high–), 比pivotkey小的结束high移动，交换low和high的值 (2) 从low往右每个记录依次与pivotkey比较，比pivotkey小或相等的，low往右移(low++), 比pivotkey小的结束low移动，交换low和high的值 返回pivotkey的值算法实现java实现1int a[10] = &#123;4,3,2,6,1,9,5,8,7,0&#125;; 12345678910111213141516171819202122232425private static void quickSort(int[] a,int low, int high)&#123; if (low&lt;high)&#123; int povit = partition(a,low,high); quickSort(a,povit+1,high); //对枢纽记录右边子表进行排序 quickSort(a,low,povit-1); //对枢纽记录左边的子表进行排序 &#125;&#125;private static int partition(int[] a, int low, int high)&#123; System.out.println(&quot;low = &quot; + low); int pivot = a[low]; //用子表的第一个记录作为枢纽记录 while (low&lt;high)&#123; // while (low&lt;high &amp;&amp; a[high]&gt;=pivot) //右往左比较 high--; //如果记录比枢纽记录大或者相等，high向左移动一个 swap(a,low,high); //交换，比枢纽记录小的放左边 show(a); while (low&lt;high &amp;&amp; a[low]&lt;=pivot) //左往右比较 low++; //如果记录比枢纽记录小或者相等，high向右移动一个 swap(a,low,high); //交换，比枢纽记录大的放右边 show(a); &#125; System.out.println(&quot;pivot = &quot; + pivot); System.out.println(); return low;&#125; 调用1quickSort(a, 0, a.length-1); 运行结果1234567891011121314151617181920212223242526272829303132333435363738原序列: 1 6 5 9 3 8 2 7 0 4 low = 00 6 5 9 3 8 2 7 1 4 0 1 5 9 3 8 2 7 6 4 0 1 5 9 3 8 2 7 6 4 0 1 5 9 3 8 2 7 6 4 pivot = 1low = 20 1 4 9 3 8 2 7 6 5 0 1 4 5 3 8 2 7 6 9 0 1 4 2 3 8 5 7 6 9 0 1 4 2 3 5 8 7 6 9 0 1 4 2 3 5 8 7 6 9 0 1 4 2 3 5 8 7 6 9 pivot = 5low = 60 1 4 2 3 5 6 7 8 9 0 1 4 2 3 5 6 7 8 9 pivot = 8low = 60 1 4 2 3 5 6 7 8 9 0 1 4 2 3 5 6 7 8 9 pivot = 6low = 20 1 3 2 4 5 6 7 8 9 0 1 3 2 4 5 6 7 8 9 pivot = 4low = 20 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 pivot = 3排序后: 0 1 2 3 4 5 6 7 8 9 选择排序思想一个简单的选择排序算法是这样的:首先, 找到数组中最小的一个元素其次, 将它和数组的第一个元素交换位置,(如果第一个元素是最小的那么它就和自己交换).再次, 在剩下元素中继续找到最小的元素,将它和数组中第二个元素交换位置.如此反复操作,直到将整个数组排序这种方法就是简单选择排序. 算法实现C语言原序列1int a[10] = &#123;4,3,2,6,1,9,5,8,7,0&#125;; 123456789101112131415161718192021/**简单选择排序 * */void SelectSort(int a[], int length)&#123; int i, j; int min; for (i = 0; i &lt; length; ++i) &#123; min = i; for (j = i+1; j &lt; length; ++j) &#123; if (a[j] &lt; a[min])&#123; min = j; &#125; //printf(&quot;min = %d\\n&quot;, min);//调试加上, &#125; if (min != i)&#123; int temp = a[i]; a[i] = a[min]; a[min] = temp; &#125; show(a,length); &#125;&#125; 运行结果:123456789101112原序列: 4 3 2 6 1 9 5 8 7 0 0 3 2 6 1 9 5 8 7 4 0 1 2 6 3 9 5 8 7 4 0 1 2 6 3 9 5 8 7 4 0 1 2 3 6 9 5 8 7 4 0 1 2 3 4 9 5 8 7 6 0 1 2 3 4 5 9 8 7 6 0 1 2 3 4 5 6 8 7 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 排序后: 0 1 2 3 4 5 6 7 8 9 java实现原序列:1int[] a = &#123;1,6,5,9,3,8,2,7,0, 4&#125;; 第一次从0-9中选择最小的与第0个交换第二次从1-9中选择最小的与第1个交换重复以上步骤123456789101112131415161718private static void selectSort(int[] a)&#123; System.out.println(\"选择排序算法:\"); int min, i, j; for (i=0; i&lt;a.length; i++)&#123; min = i; for (j=i+1; j&lt;a.length; j++)&#123; if (a[j] &lt; a[min])&#123; min = j; &#125; &#125; //System.out.println(\"min = \" + min); int temp = a[i]; a[i] = a[min]; a[min] = temp; System.out.print(\"第\" + (i+1) + \"次排序后:\"); show(a); &#125;&#125; 运行结果:12345678910111213原序列: 1 6 5 9 3 8 2 7 0 4 选择排序算法:第1次排序后:0 6 5 9 3 8 2 7 1 4 第2次排序后:0 1 5 9 3 8 2 7 6 4 第3次排序后:0 1 2 9 3 8 5 7 6 4 第4次排序后:0 1 2 3 9 8 5 7 6 4 第5次排序后:0 1 2 3 4 8 5 7 6 9 第6次排序后:0 1 2 3 4 5 8 7 6 9 第7次排序后:0 1 2 3 4 5 6 7 8 9 第8次排序后:0 1 2 3 4 5 6 7 8 9 第9次排序后:0 1 2 3 4 5 6 7 8 9 第10次排序后:0 1 2 3 4 5 6 7 8 9 排序后: 0 1 2 3 4 5 6 7 8 9 插入排序思想和整理扑克牌一样, 将每一张牌插入到其他已经有序的牌中的适当位置.在计算机实现中,为了要给插入的元素腾出空间, 我们需要将其余所有元素在插入之前都向右移动一位. 这种算法叫做插入排序. 实现C语言实现原序列1int a[10] = &#123;4,3,2,6,1,9,5,8,7,0&#125;; 12345678910111213141516/** * 直接插入排序*/void InsertSort(int a[], int length)&#123; int i,j; for (i = 0; i &lt; length- 1; ++i) &#123; for (j = i+1; j &gt; 0 ; j--) &#123; if (a[j] &lt; a[j-1])&#123; //交换 int temp = a[j]; a[j] = a[j-1]; a[j-1] = temp; &#125; &#125; show(a,MAX_SIZE); &#125;&#125; 运行结果:1234567891011原序列: 4 3 2 6 1 9 5 8 7 0 3 4 2 6 1 9 5 8 7 0 2 3 4 6 1 9 5 8 7 0 2 3 4 6 1 9 5 8 7 0 1 2 3 4 6 9 5 8 7 0 1 2 3 4 6 9 5 8 7 0 1 2 3 4 5 6 9 8 7 0 1 2 3 4 5 6 8 9 7 0 1 2 3 4 5 6 7 8 9 0 0 1 2 3 4 5 6 7 8 9 排序后: 0 1 2 3 4 5 6 7 8 9 Java实现原序列:1int[] a = &#123;1,6,5,9,3,8,2,7,0,4&#125;; 第一次把第2个数依次从右往左和1个数比较第二次把第3个数依次从右往左和2个数比较重复以上步骤 123456789101112131415private static void insertSort(int[] a)&#123; System.out.println(\"插入排序算法:\"); int i, j; for (i=0; i&lt;a.length; i++)&#123; for (j=i; j&gt;0; j--)&#123; if (a[j] &lt; a[j-1])&#123; int temp = a[j]; a[j] = a[j-1]; a[j-1] = temp; &#125; &#125; System.out.print(\"第\" + (i+1) + \"次排序后:\"); show(a); &#125;&#125; 运行结果12345678910111213原序列: 1 6 5 9 3 8 2 7 0 4 插入排序算法:第1次排序后:1 6 5 9 3 8 2 7 0 4 第2次排序后:1 6 5 9 3 8 2 7 0 4 第3次排序后:1 5 6 9 3 8 2 7 0 4 第4次排序后:1 5 6 9 3 8 2 7 0 4 第5次排序后:1 3 5 6 9 8 2 7 0 4 第6次排序后:1 3 5 6 8 9 2 7 0 4 第7次排序后:1 2 3 5 6 8 9 7 0 4 第8次排序后:1 2 3 5 6 7 8 9 0 4 第9次排序后:0 1 2 3 5 6 7 8 9 4 第10次排序后:0 1 2 3 4 5 6 7 8 9 排序后: 0 1 2 3 4 5 6 7 8 9 希尔排序思想希尔排序的思想是使数组中任意间隔为h的元素都是有序的. 这样的数组成为h有序数组简单地说, 一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组.在进行排序时, 如果h很大, 我们能将元素移动到很远的地方, 为实现更小的h有序数组创造方便, 用这种方式,对于任意以1结尾的h序列, 我们都能够将数组排序.这就是希尔排序. ## 实现 C语言实现12345678910111213141516171819202122232425/** * 希尔排序*/ void ShellSort(int a[], int length)&#123; int h = 1; //增量 //while(h &lt;= length/3) h = 3*h + 1; //增量初始值 我写的 while(h &lt; length/3) h = 3*h + 1; //增量初始值 while (h &gt;= 1)&#123; //对每个增量都进行排序 int i; for (i = h; i &lt; length; ++i) &#123; //对同一增量的每个分组进行排序 int j; //for (j = i; j &lt; length; j= j-h) &#123; //对每个分组进行插入排序 我写的 for (j = i; j &gt;= h; j= j-h) &#123; //对每个分组进行插入排序 if(a[j] &lt; a[j-h])&#123; int temp = a[j]; a[j] = a[j-h]; a[j-h] = temp; &#125; &#125; &#125; show(a,MAX_SIZE); h = h/3; &#125;&#125; 运行结果1234原序列: 4 3 2 6 1 9 5 8 7 0 1 0 2 6 4 3 5 8 7 9 0 1 2 3 4 5 6 7 8 9 排序后: 0 1 2 3 4 5 6 7 8 9 Java实现1234567891011121314151617181920private static void shellSort(int[] a)&#123; int N = a.length; int h = 1; while (h &lt; (N/3)) h = h * 3 + 1; while (h &gt;= 1)&#123; for (int i=h; i&lt;N; i++)&#123; for (int j=i; j&gt;=h;j=j-h)&#123; //进行插入排序 if (a[j] &lt; a[j-h])&#123; int temp = a[j]; a[j]= a[j-h]; a[j-h] = temp; &#125; &#125; &#125; System.out.print(\"h = \" + h + \": \"); show(a); h = h/3; &#125;&#125; 运行结果:1234原序列: 1 6 5 9 3 8 2 7 0 4 h = 4: 0 4 2 7 1 6 5 9 3 8 h = 1: 0 1 2 3 4 5 6 7 8 9 排序后: 0 1 2 3 4 5 6 7 8 9","categories":[{"name":"算法","slug":"算法","permalink":"https://devallever.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"https://devallever.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://devallever.github.io/tags/排序/"},{"name":"C","slug":"C","permalink":"https://devallever.github.io/tags/C/"}]},{"title":"Kotlin学习笔记 1","slug":"kotlin-note-1","date":"2017-05-22T09:30:55.000Z","updated":"2017-05-22T11:51:54.960Z","comments":true,"path":"2017/05/22/kotlin-note-1/","link":"","permalink":"https://devallever.github.io/2017/05/22/kotlin-note-1/","excerpt":"","text":"这里并没有系统的讲解Kotlin语法, 只是在做Demo时候刻意使用Kotlin语言,并记录一下使用方法如果要学习可以看看官网的文档,以及它推荐的一些书籍 Activity例如创建一个BaseActivity,则这样写12open class BaseActivity : AppCompatActivity() &#123;&#125; open: 关键字, 如果该类用来继承的要加上open, 或者abstract 继承的方式是 : 既然是Activity的子类,那么在重写onCreate方法时候会自动补全代码12345open class BaseActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) &#125;&#125; override: 不用看就知道是方法覆盖啦 fun 是定义方法 注意方法参数的表达方式跟Java有点区别,先是变量名,再指明类型. 注意问号?, Kotlin是空安全的, 这里表示Bundle可以为空, 第一次自学Kotlin,理解的不是很到位,望指正哈. Button创建了Activity自然就是添加几个按钮,监听,1234val btn_scale = findViewById(R.id.btn) as TextViewbtn_scale.setOnClickListener &#123; //do something&#125; val 定义变量, 相当与final, 之后不能修改引用,var 则是初始化以后也可以指向其他引用 findViewById(R.id.btn) as TextView找到控件之后通过 as 关键字转化TextView类型 设置监听,方法跟java一样,但是不再是传递一个OnClickListener,直接大括号{}当然也可以看看标准使用方式是这样的123btn.setOnClickListener(View.OnClickListener &#123; //do something&#125;) 如果不想每个Button设置监听都串OnClickListener,则要Activity实现OnClickListener只要在继承的类后面加入 , OnClickListener, 并从写onClick方法123456789101112131415161718class AnimationActivity : BaseActivity(), View.OnClickListener &#123; ... override fun onClick(v: View?) &#123; val intent: Intent when(v?.id)&#123; R.id.id_animation_activity_view_animation -&gt;&#123; intent = Intent(this, ViewAnimationActivity::class.java) startActivity(intent) &#125; R.id.id_animation_activity_property_animation -&gt;&#123; intent = Intent(this, PropertyAnimationActivity::class.java) startActivity(intent) &#125; &#125; &#125;&#125; 细心的你已经发现,这里有很多新奇好玩的东西,下面逐一讲解 使用分支在java使用条件的分之是通过switch(){}来使用的,而在Kotlin就是用 when 关键字12345678when(v?.id)&#123; R.id.id_animation_activity_view_animation -&gt;&#123; // do something &#125; R.id.id_animation_activity_property_animation -&gt;&#123; //do something &#125;&#125; 很明显when()括号内就是判断的类型,这里是view的id然后每个分之就是这么判断123R.id.id_animation_activity_view_animation -&gt;&#123; //do something&#125; 启动另一个Acivity123val intent: Intentintent = Intent(this, XXXActivity::class.java)startActivity(intent) 至于为什么这样用,我现在还不是很清楚哎另外,如果在某某控件的监听方法中启动另一个Activity,应该是这样,这里使用的是recyclerView的监听12intent = Intent(this@MainActivity, XXXActivity::class.java)startActivity(intent) 声明变量在声明局部变量时候, 通常使用val,但是当声明一个全局变量时候,通常使用var,并在声明的时候初始化为空, 例如1private var tv_target: TextView? = null 表示声明一个TextView对象, 并初始化为空,不初始化就报错的然后在Activity中正常使用1tv_target = findViewById(R.id.id_view_animation_activity_tv_target) as TextView 当要修改TextView的显示的值时候, 不再是setText(),1tv_target.setText(&quot;&quot;); 而是通过设置属性值方式,它会调用setText()方法1tv_target.text = &quot;hello&quot; 以后setXXX方法都是按这种方式使用 ,但上面的还是报错,因为tv_target定义为 TevtView?报错信息:1Smart cast to &apos;TextView&apos; is impossible, because &apos;tv_target&apos; is a mutable property that could have been changed by this time so 正确的姿势是1tv_target?.text = &quot;hello&quot; 定义实体类在Java中, 需要定义属性,并且创建该属性的gettet和setter方法在Kotlin中只需要这样1234class ListItem( var title: String, var description: String) 这样它会自动生成getter和setter方法,并不需要要我们实现通常我们这样使用,123var listItemA = ListItem(&quot;titleText&quot;, &quot;descriptionText&quot;)listItemA.title = &quot;HI Title&quot;listItemA.description = &quot;Hi Description&quot; 定义方法并设置参数的默认值例如在Activity中定义Toast的方法123private fun toast(message: String, length: Int=Toast.LENGTH_LONG):Unit&#123; Toast.makeText(this@MainActivity, message,length).show()&#125; Unit为返回类型,Unit表相当于示返回值为void,并且可以省略Unit,如123private fun toast(message: String, length: Int=Toast.LENGTH_LONG)&#123; Toast.makeText(this@MainActivity, message,length).show()&#125; 这里length参数指定了一个默认值就是Toast.LENGTH_LONG调用是应该这样123toast(&quot;HI Android&quot;)//或toast(&quot;Hi Android&quot;,1000) 使用RecyclerView在Activity通常定义一个ArrayList类型的全局变量,作为Adapter的参数因此这样声明一个全局变量1private var listItems: ArrayList&lt;ListItem&gt;? = null 注意这里是ArrayList? 类型 然后创建Adapter,他的构造方法如下:1234class MyRecyclerViewAdapter(private val context: Context, private val listItems: ArrayList&lt;ListItem&gt;?) : RecyclerView.Adapter&lt;MyRecyclerViewAdapter.MyViewHolder&gt;() &#123;&#125; 构造方法中listItems的类型也是ArrayList?, 因为在Activity中, 定义一个可变的全局变量时候初始化为空,因此这里与之对应初始化listItems对象12345678listItems = ArrayList&lt;ListItem&gt;()listItems?.add(ListItem(&quot;chapter1&quot;, &quot;Android Framework&quot;))listItems!!.add(ListItem(&quot;chapter2&quot;, &quot;Android Developer tools&quot;))listItems!!.add(ListItem(&quot;chapter3&quot;, &quot;Custom View&quot;))listItems!!.add(ListItem(&quot;chapter4&quot;, &quot;listView Demo&quot;))listItems!!.add(ListItem(&quot;chapter5&quot;, &quot;Scroll Analysis&quot;))listItems!!.add(ListItem(&quot;chapter6&quot;, &quot;Draw&quot;))listItems!!.add(ListItem(&quot;chapter7&quot;, &quot;Animation Demo&quot;)) 在这里不知道?. 和 !!. 到底有什么区别.有待深入研究,这时候要知道该这么用就够了最后就是这样使用1234val recyclerView = findViewById(R.id.id_main_recycler_view) as RecyclerViewval recyclerViewAdapter = MyRecyclerViewAdapter(this,listItems)recyclerView.layoutManager = LinearLayoutManager(this)recyclerView.adapter = recyclerViewAdapter","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://devallever.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://devallever.github.io/tags/Kotlin/"}]},{"title":"Android 动画 简单使用","slug":"animation-primary","date":"2017-05-22T08:54:53.000Z","updated":"2017-05-24T07:26:15.204Z","comments":true,"path":"2017/05/22/animation-primary/","link":"","permalink":"https://devallever.github.io/2017/05/22/animation-primary/","excerpt":"","text":"顺便学习一下Kotlin语言 介绍动画能带来良好的用户体验,作为Android程序员,必须掌握最最最基本的几种动画实现方式,包括透明度,位移,旋转,缩放. 属性动画属性动画是Android 3.0推出的动画框架,能实现视图动画所有动画效果,并且能完成视图动画不具备的功能. 例如一个在左上角的按钮使用视图动画将他移动到右下角,点击时候发现原来的点击监听已经不起作用了. 简单说,视图动画仅仅改变了控件的绘制,并没有改变其属性值.如果使用属性动画将它移动,那么原来的监听还是有的,这是真正的移动啊.属性动画就是这么强大 属性动画最重要的两个类 ValueAnimator ObjectAnimator 原理:属性动画作用于任何对象, 变化的属性名必须有该对象要有对应的getXXX和setXXX方法. 下面逐一讲讲 ValueAnimator12345678fun startValueAnimation()&#123; val valueAnimator = ValueAnimator.ofFloat(0f,1f) valueAnimator.duration = 3000 valueAnimator.repeatCount = 2 valueAnimator.repeatMode = ValueAnimator.RESTART //重复 //valueAnimator.repeatMode = ValueAnimator.REVERSE //倒回 valueAnimator.start()&#125; ofFloat()传入的值类型为float, 表示该值从1f 变化到 3f, 1f是初始值, 3f是最终值, ofFloat()传入的是可变参数, 即可以传入多个值,表示变化过程, 如: ofFloat(1f, 3f, 2f, 5f), 这里逐步并不是一下子从1f直接变化到3f,而是有个过程,每个过程值都不一样, 也许这里看不到变化, 但是动画所设置的值是变化了的, ObjectAnimatorObjectAnimator继承了ValueAnimator, 所以可以使用父类方法对动画进行一些通用设置, 不同的是创建ObjectAnimator对象 透明动画12345fun startAlpha(view: View)&#123; val alphaAnimator = ObjectAnimator.ofFloat(view,&quot;alpha&quot;, 1f,0f,1f) alphaAnimator.duration = 1000 alphaAnimator.start()&#125; view: 动画作用的对象 “alpha”: 值变化属性名, 及view对象中必须要有getAlpha()和serAlpha()方法, 1f,0f,1f: 表示变化过程, 不透明-&gt;全透明-&gt;不透明 旋转动画如旋转30度: 12345fun startRotate(view: View)&#123; val rotateAnimator = ObjectAnimator.ofFloat(view,&quot;rotation&quot;, 0f,360f) rotateAnimator.duration = 1000 rotateAnimator.start()&#125; 位移动画X轴位移123456fun startTranslateX(view: View)&#123; val currentX: Float= view.translationX val translateXAnimator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,currentX,-500f,currentX,500f,currentX) translateXAnimator.duration = 1000 translateXAnimator.start()&#125; currentX: view原来的X坐标值 动画过程,从原来位置开始,左移500像素,回到原来位置,右移500像素,回到原来位置Y轴位移123456fun startTranslateY(view: View)&#123; val currentY: Float= view.translationY val translateYAnimator = ObjectAnimator.ofFloat(view,&quot;translationY&quot;,currentY,-500f,currentY,500f,currentY) translateYAnimator.duration = 1000 translateYAnimator.start()&#125; 缩放动画同样，支持Ｘ方向 和Ｙ方向 X轴缩放12345fun startScaleX(view: View)&#123; val scaleXAnimator = ObjectAnimator.ofFloat(view,&quot;scaleX&quot;,1F,3F,1F) scaleXAnimator.duration = 1000 scaleXAnimator.start()&#125; 动画集合12345678910111213fun startAnimatorSet(view: View)&#123; val animatorSet = AnimatorSet() val alphaAnimator = ObjectAnimator.ofFloat(view,&quot;alpha&quot;, 1f,0f,1f) val rotateAnimator = ObjectAnimator.ofFloat(view,&quot;rotation&quot;, 0f,360f) val scaleXAnimator = ObjectAnimator.ofFloat(view,&quot;scaleX&quot;,1F,3F,1F) animatorSet.play(alphaAnimator).after(rotateAnimator).after(scaleXAnimator) animatorSet.duration = 2000 animatorSet.start()&#125; 使用XML动画在res建立animator文件夹在animator下创建动画的xml文件,如:12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:ordering=&quot;sequentially&quot;&gt; &lt;objectAnimator android:propertyName=&quot;alpha&quot; android:duration=&quot;500&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0&quot; android:valueType=&quot;floatType&quot;&gt; &lt;/objectAnimator&gt; &lt;objectAnimator android:propertyName=&quot;alpha&quot; android:duration=&quot;500&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;1&quot; android:valueType=&quot;floatType&quot;&gt; &lt;/objectAnimator&gt; &lt;set android:ordering=&quot;together&quot;&gt; &lt;objectAnimator android:propertyName=&quot;rotation&quot; android:duration=&quot;1000&quot; android:valueFrom=&quot;0&quot; android:valueTo=&quot;360&quot; android:valueType=&quot;floatType&quot;&gt; &lt;/objectAnimator&gt; &lt;set android:ordering=&quot;sequentially&quot;&gt; &lt;objectAnimator android:propertyName=&quot;scaleY&quot; android:duration=&quot;500&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;3&quot; android:valueType=&quot;floatType&quot;&gt; &lt;/objectAnimator&gt; &lt;objectAnimator android:propertyName=&quot;scaleY&quot; android:duration=&quot;500&quot; android:valueFrom=&quot;3&quot; android:valueTo=&quot;1&quot; android:valueType=&quot;floatType&quot;&gt; &lt;/objectAnimator&gt; &lt;/set&gt; &lt;/set&gt;&lt;/set&gt; 在代码中这样调用12345fun startXMLAnimation(view: View)&#123; val animator = AnimatorInflater.loadAnimator(this,R.animator.animator_test) animator.setTarget(view) animator.start()&#125; 视图动画透明度动画12345678/** * 1:不透明 * 0:全透明**/fun startAlpha()&#123; val alphaAnimation = AlphaAnimation(0f,1f) alphaAnimation.duration = 1000 tv_target?.startAnimation(alphaAnimation)&#125; 旋转动画12345678910111213141516/** * 参数1: 开始角 * 参数2: 旋转角 * 参数3: **/fun startRotate()&#123; //val rotateAnimation = RotateAnimation(0f,360f,0f,0f) //以自身中心旋转 val rotateAnimation = RotateAnimation( 0f,360f, RotateAnimation.RELATIVE_TO_SELF,0.5F, RotateAnimation.RELATIVE_TO_SELF,0.5F ) rotateAnimation.duration = 1000 tv_target?.startAnimation(rotateAnimation)&#125; 位移动画12345678910/** * fromX * toX * fromY * toY**/fun startTranslate()&#123; val translateAnimation = TranslateAnimation(0f,200f,0f,300f) translateAnimation.duration = 1000 tv_target?.startAnimation(translateAnimation)&#125; 缩放动画1234567891011121314/** * fromX * toX * fromY * toY**/fun startScale()&#123; //val scaleAnimation = ScaleAnimation(0f,2f,0f,2f) //设置中心点缩放 val scaleAnimation = ScaleAnimation(0f,2f,0f,2f, ScaleAnimation.RELATIVE_TO_SELF,0.5F, ScaleAnimation.RELATIVE_TO_SELF,0.5F) scaleAnimation.duration = 1000 tv_target?.startAnimation(scaleAnimation)&#125; SVG动画使用步骤 创建静态SVG图形在drawable的资源文件夹下创建xml文件,line_svg_vector.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:height=&quot;200dp&quot; android:width=&quot;200dp&quot; android:viewportHeight=&quot;100&quot; android:viewportWidth=&quot;100&quot;&gt; &lt;group&gt; &lt;path android:name=&quot;path1&quot; android:strokeColor=&quot;#3F51B5&quot; android:strokeWidth=&quot;5&quot; android:strokeLineCap=&quot;round&quot; android:pathData=&quot;M 20,80 L 50,80,80,80&quot;/&gt; &lt;path android:name=&quot;path2&quot; android:strokeColor=&quot;#3F51B5&quot; android:strokeWidth=&quot;5&quot; android:strokeLineCap=&quot;round&quot; android:pathData=&quot;M 20,20 L 50,20,80,20&quot;/&gt; &lt;/group&gt;&lt;/vector&gt; 创建动画资源xml文件在animator下创建, 每个图形都要有一个动画过程line_path_1.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/bounce_interpolator&quot; android:duration=&quot;500&quot; android:propertyName=&quot;pathData&quot; android:valueFrom=&quot;M 20,80 L 50,80,80,80&quot; android:valueTo=&quot;M 20,80 L 50,50,80,80&quot; android:valueType=&quot;pathType&quot; &gt;&lt;/objectAnimator&gt; line_path_2.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/bounce_interpolator&quot; android:duration=&quot;500&quot; android:propertyName=&quot;pathData&quot; android:valueFrom=&quot;M 20,20 L 50,20,80,20&quot; android:valueTo=&quot;M 20,20 L 50,50,80,20&quot; android:valueType=&quot;pathType&quot; &gt;&lt;/objectAnimator&gt; 把静态SVG和动画资源联合起来在drawable-v21目录下创建xml文件:line_animated_vector.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/line_svg_vector&quot;&gt; &lt;target android:animation=&quot;@animator/line_path_1&quot; android:name=&quot;path1&quot;/&gt; &lt;target android:animation=&quot;@animator/line_path_2&quot; android:name=&quot;path2&quot;/&gt;&lt;/animated-vector&gt; 使用SVG资源12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/id_svg_animation_activity_iv_line_svg&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;150dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:src=&quot;@drawable/line_animated_vector&quot;/&gt; &lt;ImageView android:id=&quot;@+id/id_svg_animation_activity_iv_sun_system_svg&quot; android:layout_width=&quot;150dp&quot; android:layout_height=&quot;150dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:src=&quot;@drawable/sun_system_animated_vector&quot;/&gt;&lt;/LinearLayout&gt; 开启动画点击时候开启动画1234fun startLineSVGAnimation(imageView: ImageView)&#123; val drawable = imageView.drawable (drawable as Animatable).start()&#125; kotlin语言","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Animation","slug":"Animation","permalink":"https://devallever.github.io/tags/Animation/"}]},{"title":"Hello Kotlin","slug":"hello-kotlin","date":"2017-05-21T09:26:42.000Z","updated":"2017-05-21T10:03:42.521Z","comments":true,"path":"2017/05/21/hello-kotlin/","link":"","permalink":"https://devallever.github.io/2017/05/21/hello-kotlin/","excerpt":"","text":"在此仅整理所学资料原文地址: 《Kotlin for android developers》中文版翻译 介绍什么是Kotlin？Kotlin，如前面所说，它是JetBrains开发的基于JVM的语言。JetBrains因为创造了一个强大的Java开发IDE被大家所熟知。Android Studio，官方的Android IDE，就是基于Intellij，作为一个该平台的插件。Kotlin是使用Java开发者的思维被创建的，Intellij作为它主要的开发IDE。对于Android开发者，有两个有趣的特点： 对Java开发者来说，Kotlin是非常直觉化的，并且非常容易学习。语言的大部分内容都是与我们知道的非常相似，不同的地方，它的基础概念也能迅速地掌握它。 它与我们日常生活使用的IDE无需配置就能完全整合。Android Studio能够非常完美地理解、编译运行Kotlin代码。而且对这门语言的支持来正是自于开发了这个IDE的公司本身，所以我们Android开发者是一等公民。但是这仅仅是开发语言和开发工具之间的整合。相比Java 7的优势到底是什么呢？ 它更加易表现：这是它最重要的优点之一。你可以编写少得多的代码。 它更加安全：Kotlin是空安全的，也就是说在我们编译时期就处理了各种null的情况，避免了执行时异常。如果一个对象可以是null，则我们需要明确地指定它，然后在使用它之前检查它是否是null。你可以节约很多调试空指针异常的时间，解决掉null引发的bug。 它是函数式的：Kotlin是基于面向对象的语言。但是就如其他很多现代的语言那样，它使用了很多函数式编程的概念，比如，使用lambda表达式来更方便地解决问题。其中一个很棒的特性就是Collections的处理方式。 它可以扩展函数：这意味着我们可以扩展类的更多的特性，甚至我们没有权限去访问这个类中的代码。 它是高度互操作性的：你可以继续使用所有的你用Java写的代码和库，因为两个语言之间的互操作性是完美的。甚至可以在一个项目中使用Kotlin和Java两种语言混合编程。 我们通过什么获得Kotlin不深入Kotlin语言（我们会在下一章再去学习），这里有一些Java中没有的有趣的特性： 易表现通过Kotlin，可以更容易地避免模版代码因为大部分的典型情况都在语言中默认覆盖实现了。举个例子，在Java中，如果我们要典型的数据类，我们需要去编写（至少生成）这些代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Artist &#123; private long id; private String name; private String url; private String mbid; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getMbid() &#123; return mbid; &#125; public void setMbid(String mbid) &#123; this.mbid = mbid; &#125; @Override public String toString() &#123; return &quot;Artist&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, url=&apos;&quot; + url + &apos;\\&apos;&apos; + &quot;, mbid=&apos;&quot; + mbid + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 使用Kotlin，我们只需要通过数据类：123456data class Artist( var id: Long, var name: String, var url: String, var mbid: String) 这个数据类，它会自动生成所有属性和它们的访问器，以及一些有用的方法，比如， toString() 空安全当我们使用Java开发的时候，我们的代码大多是防御性的。如果我们不想遇到 NullPointerException ，我们就需要在使用它之前不停地去判断它是否为null。Kotlin，如很多现代的语言，是空安全的，因为我们需要通过一个 安全调用操作符 （写做 ? ）来明确地指定一个对象是否能为空。我们可以像这样去写：123456789101112131415161718192021// 这里不能通过编译. Artist 不能是nullvar notNullArtist: Artist = null// Artist 可以是 nullvar artist: Artist? = null// 无法编译, artist可能是null，我们需要进行处理artist.print()// 只要在artist != null时才会打印artist?.print()// 智能转换. 如果我们在之前进行了空检查，则不需要使用安全调用操作符调用if (artist != null) &#123; artist.print()&#125;// 只有在确保artist不是null的情况下才能这么调用，否则它会抛出异常artist!!.print()// 使用Elvis操作符来给定一个在是null的情况下的替代值val name = artist?.name ?: &quot;empty&quot; 扩展方法我们可以给任何类添加函数。它比那些我们项目中典型的工具类更加具有可读性。举个例子，我们可以给fragment增加一个显示toast的函数：123fun Fragment.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123; Toast.makeText(getActivity(), message, duration).show()&#125; 我们现在可以这么做：1fragment.toast(&quot;Hello world!&quot;) 函数式支持（Lambdas）每次我们去声明一个点击所触发的事件，可以只需要定义我们需要做些什么，而不是不得不去实现一个内部类？我们确实可以这么做，这个（或者其它更多我们感兴趣的事件）我们需要感谢lambda：1view.setOnClickListener &#123; toast(&quot;Hello world!&quot;) &#125; 这里只是挑选了很小一部分Kotlin可以简化我们代码的事情。现在你已经知道这门语言的一些有趣的特性了，你可以考虑它是否是适合你的。如果你选择继续，我们将在下一章开始我们的实践之旅。 #准备工作现在你知道使用Kotlin实现的小例子了，我确信你会希望尽可能快地把它用在你的实践当中去。不要担心，在第一章中会帮助你去搭建你的开发环境，这样你才能立即编写代码。 Android Studio第一件事就是安装Android Studio。就如你知道的，Android Studio是官方的Android IDE，它是2013年发布的预览版，并在2014年发布了正式版。Android Studio是Intellij IDEA的插件实现，Intellij IDEA是由JetBrains开发，Kotlin就是JetBrains创造的。所以，正如你所见，一切都这么紧密地结合起来了。转移Android Studio是Android开发者一个重要的改变。首先，因为我们放弃了Eclipse并转到专为Java开发者设计的完美的语言交互的软件。我们可以享受到完美的特性体验，比如反应快速和令人影响深刻的智能代码提示，还有强大的分析和重构工具。第二，Gradle成为Android官方的系统构建工具，这意味着版本构建和部署的新的可能性。最有趣的两点是系统构建和flavours，它可以让你使用相同的代码库来创建无限的版本（甚至是不同的应用）。如果你仍然在使用Eclipse，为了跟上这本书，恐怕你需要转移到Android Studio了。Kotlin团队也创建了一个针对Eclipse的插件，但是它是远远落后于Android Studio的，而且结合得也并不完美。你一旦使用了它，你就会觉得相见恨晚。我不会去覆盖到Android Studio和Gradle的使用，因为这些都不是本书的重点，但是如果你以前没有使用过这些工具，不要恐慌，我确信你能够跟随本书的同时学习到相关基础。如果你还没有AndroidStudio，点这里从官网下载。 安装Kotlin插件IDE它本身并不能理解Kotlin。就像前面部分讲到，它是为Java开发设计的。但是Kotlin团队创建了一系列强大的插件让我们更轻松地实现。前往Android Studio的 Preferences 中 Plugin 栏，然后安装如下两个插件： Kotlin：这是一个基础的插件。它能让Android Studio懂得Kotlin代码。它会每次在新的Kotlin语言版本发布的时候发布新的插件版本，这样我们可以通过它发现新版本特性和弃用的警告。这是你要使用Kotlin编写Android应用唯一的插件。但是我们现在还需要另外一个。 Kotlin Android Extensions：Kotlin团队还为Android开发发布了另外一个有趣的插件。这个Android Extensions可以让你自动地从XML中注入所有的View到Activity中，举个例子，你不需要使用 findViewById() 。你将会立即得到一个从属性转换过来的view。你将需要安装这个插件来使用这个特性。我们会在下一章中深入地去讲解这个。 因为从Intellij 15开始，插件是被默认安装了的，但是你的Android Studio可能并没有。所以你需要进入Android Studio 的Preferences的plugin栏，然后安装Kotlin插件。如果你不会就去搜索下。现在我们的环境已经可以理解Kotlin语言了，可以就像我们使用Java一样无缝地编译它，执行它。 创建一个新的项目如果你已经使用过Android Studio和Gradle，那么这一章会比较简单。我不会给出很多细节和截图，因为用户界面和细节可能会一直变化。我们的应用是由一个简单的天气app组成，正如所使用的Google’s Beginners Course in Udacity。我们可能会关注不同的事情，但是app的想法都是一样的，你会发现在一个典型的app里面会包括很多不同的东西。如果你的Android开发水平比较低，我推荐这个，这个过程是比较容易的。 在Android Studio中创建一个项目首先，打开Android Studio并选择 Create new Project ，然后它会让你输入一个名字，你可以任意取一个名字，比如： Weather App 。然后你需要输入公司域名。如果你不会真正发布这个app，这个字段就不是特别重要了，但是如果你有的话可以使用自己的域名。然后给任意选择一个目录作为这个项目的保存地址。下一步，它会让你选择最小的API版本。我们选择API 15，因为我们有一个库需要至少API 15才能用。无论如何你把大部分的Anroid用户作为了目标。现在不要选择任何除了手机和平板的其它平台。最后，我们需要选择一个Activity模版来作为入口。我们可以选择 Add no Activity 然后从头开始（这是一个好的方式如果这是一个Kotlin项目的话），但是我将选择 Blank Activity ，因为我待会儿会给你展示Kotlin插件一个好玩的小特性。暂时不用去关心Activity的名字，layout等。这些你会在下一篇中知道。如果我们需要，我待会儿会修改它。点击 Finish 然后让它继续创建项目。 配置GradleKotlin插件包括一个让我们配置Gradle的工具。但是我还是倾向于保持我对Gradle文件读写的控制权，否则它只会变得混乱而不会变得简单。不管怎么样，在使用自动工具之前知道它是怎么工作的是个不错的主意。所以这次，我们将手动去做。首先，你需要如下修改父 build.gradle ：1234567891011121314151617buildscript &#123; ext.support_version = &apos;23.1.1&apos; ext.kotlin_version = &apos;1.0.0&apos; ext.anko_version = &apos;0.8.2&apos; repositories &#123; jcenter() dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.5.0&apos; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; &#125; &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 正如你看到的，我们创建了一个变量来存储当前的Kotlin版本。你读到这里的时候去检测一下最新版本，因为可能会有更新的版本已经发布了。我们需要在几个不同的地方用到那个版本号，比如你需要加上新的Kotlin插件的 dependency 。你会在你指定的那些模块中的 build.gradle 中再次需要到Kotlin标准库。我们对于 support library 也是如此， Anko 库也是同样的做法。用这个方式可以更方便地在一个地方修改所有的版本号。并且使用相同的版本号，更新的时候也不需要每个地方都修改。我们会增加 Kotlin 标准库， Anko 库，以及 Kotlin 和 Kotlin Android Extensions plugin 插件到dependencies。123456789101112131415161718192021apply plugin: &apos;com.android.application&apos;apply plugin: &apos;kotlin-android&apos;apply plugin: &apos;kotlin-android-extensions&apos;android &#123; ...&#125;dependencies &#123; compile &quot;com.android.support:appcompat-v7:$support_version&quot; compile &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot; compile &quot;org.jetbrains.anko:anko-common:$anko_version&quot;&#125;buildscript &#123; repositories &#123; jcenter() &#125;dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version&quot; &#125; &#125; Anko是一个用来简化一些Android任务的很强大的Kotlin库。我们之后将会学习部分anko，但是现在来说仅仅增加 anko-common 就足够了。这个库被分割成了一系列小的部分以至于我们不会把没用到的部分加进来。 把MainActivity转换成Kotlin代码Kotlin plugin包含了一个有趣的特性，它能把Java代码转成Kotlin代码。正如任何自动化那样，结果不会很完美，但是在你第一天能够使用Kotlin语言开始编写代码之前，它还是提供了很多的帮助。所以我们在MainActivity.java类中使用它。打开文件，然后选择 Code -&gt; Convert Java File to Kotlin File 。对比它们的不同之处，可以让你更熟悉这门语言。 测试是否一切就绪我们想再将编写一些代码来测试Kotlin Android Extensions是否在工作。我现在还不会对这些代码做解释，但是我想要确保它们在你的环境中是正常运行的。这可能是配置中最难的一部分。首先，打开 activity_main.xml ，然后设置TextView的id：12345&lt;TextView android:id=&quot;@+id/message&quot; android:text=&quot;@string/hello_world&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 然后，手动在Activity中增加一个import语句（不要担心你现在对这个还不太理解）。1import kotlinx.android.synthetic.main.activity_main.* 在 onCreate 中，你现在可以直接得到并访问这个TextView了。12345override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) message.text = &quot;Hello Kotlin!&quot;&#125; 多亏Kotlin和Java之间的互操作性，我们可以在Kotlin中像操作属性一样去操作Java库中的getter/setter方法。我们之后再去讲解属性，但是我想提醒的是，我们可以使用 message.text 来代替 message.setText 。编译器将会把它转换成一般的Java代码，所以这样使用是没有任何性能开销的。现在运行这个app，并且它是正常运行的。检查TextView是否是显示的新的内容。如果你有疑问或者想查看代码，请在Kotlin for Android Developers repository查看。每个章节只要修改了代码，我都会进行提交，所以一定要检查所有的代码变化。下一章会覆盖你在转换之后的MainActivity所看到的新的东西。一旦你理解了Java和Kotlin之间的细微的变化，你将能更容易独立写新的代码了。 类和函数Kotlin中的类遵循一个简单的结构。尽管与Java有一点细微的差别。你可以使用try.kotlinlang.org在不需要一个真正的项目和不需要部署到机器的前提下来测试一些简单的代码范例。 怎么定义一个类如果你想定义一个类，你只需要使用 class 关键字。123class MainActivity&#123;&#125; 它有一个默认唯一的构造器。我们会在以后的课程中学习在特殊的情况下创建其它额外的构造器，但是请记住大部分情况下你只需要这个默认的构造器。你只需要在类名后面写上它的参数。如果这个类没有任何内容可以省略大括号：1class Person(name: String, surname: String) 那么构造函数的函数体在哪呢？你可以写在 init 块中：12345class Person(name: String, surname: String) &#123; init&#123; ... &#125;&#125; 类继承默认任何类都是基础继承自 Any （与java中的 Object 类似），但是我们可以继承其它类。所有的类默认都是不可继承的（final），所以我们只能继承那些明确声明 open 或者 abstract 的类：12open class Animal(name: String)class Person(name: String, surname: String) : Animal(name) 当我们只有单个构造器时，我们需要在从父类继承下来的构造器中指定需要的参数。这是用来替换Java中的 super 调用的。 函数函数（我们Java中的方法）可以使用 fun 关键字就可以定义:12fun onCreate(savedInstanceState: Bundle?) &#123;&#125; 如果你没有指定它的返回值，它就会返回 Unit ，与Java中的 void 类似，但是 Unit 是一个真正的对象。你当然也可以指定任何其它的返回类型：123fun add(x: Int, y: Int) : Int &#123; return x + y&#125; 小提示：分号不是必须的 就想你在上面的例子中看到的那样，我在每句的最后没有使用分号。当然你也可以使用分号，分号不是必须的，而且不使用分号是一个不错的实践。当你这么做了，你会发现这节约了你很多时间。然而如果返回的结果可以使用一个表达式计算出来，你可以不使用括号而是使用等号：1fun add(x: Int,y: Int) : Int = x + y 构造方法和函数参数Kotlin中的参数与Java中有些不同。如你所见，我们先写参数的名字再写它的类型：123fun add(x: Int, y: Int) : Int &#123; return x + y&#125; 我们可以给参数指定一个默认值使得它们变得可选，这是非常有帮助的。这里有一个例子，在Activity中创建了一个函数用来toast一段信息：123fun toast(message: String, length: Int = Toast.LENGTH_SHORT) &#123; Toast.makeText(this, message, length).show()&#125; 如你所见，第二个参数（length）指定了一个默认值。这意味着你调用的时候可以传入第二个值或者不传，这样可以避免你需要的重载函数：12toast(&quot;Hello&quot;)toast(&quot;Hello&quot;, Toast.LENGTH_LONG) 这个与下面的Java代码是一样的：123456void toast(String message)&#123;&#125;void toast(String message, int length)&#123; Toast.makeText(this, message, length).show();&#125; 这跟你想象的一样复杂。再看看这个例子：12345fun niceToast(message: String, tag: String = javaClass&lt;MainActivity&gt;().getSimpleName(), length: Int = Toast.LENGTH_SHORT) &#123; Toast.makeText(this, &quot;[$className] $message&quot;, length).show()&#125; 我增加了第三个默认值是类名的tag参数。如果在Java中总数开销会以几何增长。现在可以通过以下方式调用：123toast(&quot;Hello&quot;)toast(&quot;Hello&quot;, &quot;MyTag&quot;)toast(&quot;Hello&quot;, &quot;MyTag&quot;, Toast.LENGTH_SHORT) 而且甚至还有其它选择，因为你可以使用参数名字来调用，这表示你可以通过在值前写明参数名来传入你希望的参数：1toast(message = &quot;Hello&quot;, length = Toast.LENGTH_SHORT) 小提示：String模版你可以在String中直接使用模版表达式。它可以帮助你很简单地在静态值和变量的基础上编写复杂的String。在上面的例子中，我使用了”[$className] $message”。 如你所见，任何时候你使用一个 $ 符号就可以插入一个表达式。如果这个表达式有一点复杂，你就需要使用一对大括号括起来：”Your name is ${user.name}”。","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://devallever.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://devallever.github.io/tags/Kotlin/"}]},{"title":"JavaWeb 项目搭建Hibernate环境","slug":"hibernate-config","date":"2017-05-19T08:31:34.000Z","updated":"2017-05-19T09:58:34.929Z","comments":true,"path":"2017/05/19/hibernate-config/","link":"","permalink":"https://devallever.github.io/2017/05/19/hibernate-config/","excerpt":"","text":"环境 Eclipse MySQL 下载Hibernate所需jar包可到官网下载: 快速通道 下载好后解压，打开压缩包下的lib目录下的require文件夹，这是hibernate的所以来的必须的jar包，copy到Project/WebContent/WEB-INF/lib 目录下，并添加依赖, 没有的自行创建 由于我们需要连接MySQL数据库，将所需的mysql-connector-java-5.0.8-bin.jar引用进去，关于这些jar包，可以在网上搜索。 注意这里我用的是4.2版本的hibernate-core-4.2.1.Final.jar 配置Hibernate.conf.xml我们需要配置最重要的hibernate配置文件hibernate.cfg.xml以及进行日志处理的log4j.properties属性文件：打开上一步解压后的hibernate文件夹，打开project—&gt;etc文件夹，将该文件夹下的hibernate.cfg.xml和log4j.properties文件拷贝到项目的src文件夹下，打开hibernate.cfg.xml文件，将session-factory标签中的内容替换成如下的内容：1234567891011121314&lt;session-factory&gt; &lt;!-- MySQL --&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306?useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/property&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;dixm&lt;/property&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hibernate.use_sql_comments&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot;&gt;0&lt;/property&gt; &lt;!-- Mappings --&gt; &lt;/session-factory&gt; 自动生成数据库表创建DDLCreator类123456789101112131415import org.hibernate.cfg.Configuration;import org.hibernate.tool.hbm2ddl.SchemaExport;public class DDLCreator &#123; /** * @param args */ public static void main(String[] args) &#123; Configuration cfg = new Configuration().configure(); SchemaExport se = new SchemaExport(cfg); se.drop(true, true); //ɾ se.create(true, true); // &#125;&#125; 创建HibernateUtil类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;@SuppressWarnings(&quot;deprecation&quot;)public class HibernateUtil &#123; private static SessionFactory sessionFactory; static &#123; try &#123; sessionFactory = new Configuration().configure().buildSessionFactory(); &#125; catch (Throwable ex) &#123; throw new ExceptionInInitializerError(ex); &#125; &#125; public static SessionFactory getSessionFactory() &#123; // Alternatively, you could look up in JNDI here return sessionFactory; &#125; public static void shutdown() &#123; // Close caches and connection pools getSessionFactory().close(); &#125; public static Session getSession() &#123; Session session = sessionFactory.openSession(); return session; &#125; public static void beginSession(Session session) &#123; session.getTransaction().begin(); &#125; public static void commitTransaction(Session session) &#123; session.getTransaction().commit(); &#125; public static void rollbackTransaction(Session session) &#123; Transaction tx = session.getTransaction(); if (tx.isActive()) tx.rollback(); &#125;&#125; 创建实体类如 TVersion1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;@Entity //表示实体类@Table(catalog = &quot;dbcoolweather&quot;) //数据库名public class TVersion &#123; private long id; private int version_code; private String version_name; private String description; private String path; //主键，自增 @Id @GeneratedValue(strategy=GenerationType.AUTO) public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public int getVersion_code() &#123; return version_code; &#125; public void setVersion_code(int version_code) &#123; this.version_code = version_code; &#125; public String getVersion_name() &#123; return version_name; &#125; public void setVersion_name(String version_name) &#123; this.version_name = version_name; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getPath() &#123; return path; &#125; public void setPath(String path) &#123; this.path = path; &#125;&#125; 在Hibernate.cfg.xml中添加映射关系12&lt;!-- Mappings --&gt;&lt;mapping class=&quot;com.allever.mycoolweather.bean.TVersion&quot;/&gt; 创建数据库首先在MySQL中手动创建数据库： dbcoolweather 运行DDLCreator类刷新数据库表，此时，tversion表已经建好了, 有木有很惊讶～～～ 对数据库进行增删改查创建VersionDAO类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import java.util.List;import org.hibernate.Query;import org.hibernate.Session;import com.allever.mycoolweather.bean.TVersion;import com.allever.mycoolweather.util.HibernateUtil;public class VersionDAO &#123; Session session = null; boolean commit = false; public VersionDAO() &#123; this.session = HibernateUtil.getSession(); commit = true; HibernateUtil.beginSession(session); &#125; public VersionDAO(Session session) &#123; this.session = session; commit = false; &#125; public void close() &#123; if (commit == true) &#123; HibernateUtil.commitTransaction(session); session.close(); &#125; &#125; public Session getSession() &#123; return session; &#125; public TVersion getById(long id) throws Exception &#123; TVersion d = null; try &#123; d = (TVersion) session.get(TVersion.class, id); &#125; catch (Exception e) &#123; HibernateUtil.rollbackTransaction(session); throw e; &#125; return d; &#125; @SuppressWarnings(&quot;unchecked&quot;) public List&lt;TVersion&gt; getByQuery(String conditions, long start, long limit) throws Exception &#123; List&lt;TVersion&gt; dl = null; try &#123; String hql = &quot;from TVersion&quot;; if ((conditions != null) &amp;&amp; (conditions.length() &gt; 0)) hql += &quot; where &quot; + conditions; Query query = session.createQuery(hql); if (limit &gt; 0) &#123; query.setFirstResult((int) start); query.setMaxResults((int) limit); &#125; dl = (List&lt;TVersion&gt;) query.list(); &#125; catch (Exception e) &#123; HibernateUtil.rollbackTransaction(session); throw e; &#125; return dl; &#125; @SuppressWarnings(&quot;unchecked&quot;) public List&lt;TVersion&gt; getUpdateVersion(long start,long limit) throws Exception &#123; List&lt;TVersion&gt; dl = null; try &#123; String hql = &quot;from TVersion ORDER BY version_code DESC&quot;; Query query = session.createQuery(hql); if (limit &gt; 0) &#123; query.setFirstResult((int) 0); query.setMaxResults((int) 0); &#125; dl = (List&lt;TVersion&gt;) query.list(); &#125; catch (Exception e) &#123; HibernateUtil.rollbackTransaction(session); throw e; &#125; return dl; &#125; public TVersion add(TVersion d) throws Exception &#123; Long id = null; try &#123; id = (Long) session.save(d); &#125; catch (Exception e) &#123; HibernateUtil.rollbackTransaction(session); throw e; &#125; return getById(id); &#125; public void deleteById(long id) throws Exception &#123; TVersion d = null; try &#123; d = (TVersion) session.get(TVersion.class, id); if (d != null) session.delete(d); &#125; catch (Exception e) &#123; HibernateUtil.rollbackTransaction(session); throw e; &#125; &#125; public TVersion update(TVersion d) throws Exception &#123; try &#123; session.update(d); &#125; catch(RuntimeException e) &#123; HibernateUtil.rollbackTransaction(session); throw e; &#125; return getById(d.getId()); &#125;&#125; 各位看函数名就知道要干什么了吧，这里就不哆嗦了 创建VersionTest类进行测试12345public class VersionTest &#123; public static void main(String[] args)&#123; &#125;&#125; 就是一个普通的JAVA类 初始化DAO123VersionDAO dao = new VersionDAO();//operationdao.close(); 增加一条记录123456789101112try&#123; TVersion v1 = new TVersion(); v1.setVersion_code(5); v1.setDescription(&quot;第3版&quot;); v1.setVersion_name(&quot;1.3&quot;); v1.setPath(&quot;/apk/mycoolweather_1.3.apk&quot;); dao.add(v1);&#125;catch(Exception e)&#123; e.printStackTrace();&#125;finally&#123; dao.close();&#125; 查询一条记录123456List&lt;TVersion&gt; list_tversion = new ArrayList&lt;&gt;();list_tversion = dao.getByQuery(&quot;version_code=&quot;+ 5, 0, 0);if(list_tversion.size()&gt;0)&#123; TVersion v = list_tversion.get(0); v.getVersion_name();&#125; 查询所有记录1234567List&lt;TVersion&gt; list_tversion = new ArrayList&lt;&gt;();// null or &quot;&quot;list_tversion = dao.getByQuery(null, 0, 0);for(TVersion tversion: list_tversion)&#123; tversion.getVersion_name(); System.out.println(tversion.getDescription());&#125; 修改数据1234567List&lt;TVersion&gt; list_tversion = new ArrayList&lt;&gt;();list_tversion = dao.getByQuery(&quot;version_code=&quot;+ 5, 0, 0);if(list_tversion.size()&gt;0)&#123; TVersion v = list_tversion.get(0); v.setDescription(&quot;new Description&quot;); dao.update(v);&#125; 删除数据1234567List&lt;TVersion&gt; list_tversion = new ArrayList&lt;&gt;();list_tversion = dao.getByQuery(&quot;version_code=&quot;+ 5, 0, 0);if(list_tversion.size()&gt;0)&#123; TVersion v = list_tversion.get(0); v.setDescription(&quot;new Description&quot;); dao.deleteById(v.getId());&#125; OK,大功告成.写这篇复习了以前所学知识，下一步，继续学习新版本的知识","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://devallever.github.io/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://devallever.github.io/tags/JavaWeb/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://devallever.github.io/tags/Hibernate/"}]},{"title":"设计模式(二) 建造者模式","slug":"builder-patterns","date":"2017-05-18T13:27:59.000Z","updated":"2017-05-19T10:03:51.711Z","comments":true,"path":"2017/05/18/builder-patterns/","link":"","permalink":"https://devallever.github.io/2017/05/18/builder-patterns/","excerpt":"","text":"定义 将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示 你看懂了吗? 反正我是一脸懵逼 UML类图 解读: Product产品类: 产品抽象类 Builder: 抽象Builder类,规划产品组建,一般是由子类实现具体的组建过程 ConcreteBuilder: 具体的Builder类 Director: 统一组建过程 好吧, 还是说的有点虚呀, 来一个简单例子 简单实现Computer抽象类类：Product角色，即产品抽象类1234567891011121314151617181920212223242526272829/** * Created by allever on 17-5-18. * 计算机抽象类: Product角色*/public abstract class Computer &#123; private String strBoard; private String strDisplay; private String strOS; protected Computer()&#123;&#125; /**CPU核心数*/ public void setBoard(String board)&#123; this.strBoard = board; &#125; public void setDisplay(String display)&#123; this.strDisplay = display; &#125; public void setStrOS(String os)&#123; this.strOS = os; &#125; @Override public String toString() &#123; String result = &quot;Computer:\\nboard=&quot; + strBoard + &quot;\\ndisplay = &quot; + strDisplay + &quot;\\nOS = &quot; + strOS; return result; &#125;&#125; MacBook类，具体Computer类12345678/** * Created by allever on 17-5-18. */public class MacBook extends Computer &#123; protected MacBook()&#123;&#125;&#125; ##Builder抽象类负责规范产品组建，一般是由子类实现具体的组建过程12345678910/** * Created by allever on 17-5-18. * 抽象Builder类*/public abstract class Builder &#123; public abstract void buildBoard(String board); public abstract void buildDisplay(String display); public abstract void buildOS(String os); public abstract Computer build();&#125; MacBookBuilder：具体Builder类，ConcreteBuilder角色12345678910111213141516171819202122232425262728/** * Created by allever on 17-5-18. * Builder实现类*/public class MacBookBuilder extends Builder &#123; private Computer computerMacBook = new MacBook(); @Override public void buildBoard(String board) &#123; computerMacBook.setBoard(board); &#125; @Override public void buildDisplay(String display) &#123; computerMacBook.setDisplay(display); &#125; @Override public void buildOS(String os) &#123; computerMacBook.setStrOS(os); &#125; @Override public Computer build() &#123; return computerMacBook; &#125;&#125; Director类：同一组装过程123456789101112131415161718/** * Created by allever on 17-5-18. * Director类： 负责构建Computer*/public class Director &#123; private Builder builder = null; public Director(Builder builder)&#123; this.builder = builder; &#125; //构建对象 public void construct(String board, String display, String os)&#123; builder.buildBoard(board); builder.buildDisplay(display); builder.buildOS(os); &#125;&#125; 客户端调用12345Builder builder = new MacBookBuilder();Director director = new Director(builder);director.construct(&quot;英特尔酷睿i7&quot;,&quot;15.6寸&quot;,&quot;Ubuntu 16.04&quot;);Log.d(TAG, builder.build().toString());Toast.makeText(BuildPatternsActivity.this,builder.build().toString(),Toast.LENGTH_LONG).show(); 小提示通常,Director角色会被省略,直接使用Builder构建对象,这个Builder通常为链式调用,即buildXXX()方法返回自身,return this; 修改后的Builder类12345678910/** * Created by allever on 17-5-18. * 抽象Builder类*/public abstract class Builder &#123; public abstract Builder buildBoard(String board); public abstract Builder buildDisplay(String display); public abstract Builder buildOS(String os); public abstract Computer build();&#125; MacBookBuilder:12345678910111213141516171819202122232425262728293031/** * Created by allever on 17-5-18. * Builder实现类*/public class MacBookBuilder extends Builder &#123; private Computer computerMacBook = new MacBook(); @Override public MacBookBuilder buildBoard(String board) &#123; computerMacBook.setBoard(board); return this; &#125; @Override public MacBookBuilder buildDisplay(String display) &#123; computerMacBook.setDisplay(display); return this; &#125; @Override public MacBookBuilder buildOS(String os) &#123; computerMacBook.setStrOS(os); return this; &#125; @Override public Computer build() &#123; return computerMacBook; &#125;&#125; 在客户端中的调用1234567Builder builder = new MacBookBuilder();//Director director = new Director(builder);//director.construct(&quot;英特尔酷睿i7&quot;,&quot;15.6寸&quot;,&quot;Ubuntu 16.04&quot;);Log.d(TAG, builder.buildBoard(&quot;英特尔酷睿i7&quot;) .buildDisplay(&quot;15.6寸&quot;) .buildOS(&quot;Max OS&quot;) build().toString()); 现在你是不是感觉到很熟悉的呢? 就像Android中构建一个Notification对象 12345678910111213141516171819202122232425Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;This is content title&quot;) .setContentText(&quot;This is content text&quot;) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setWhen(System.currentTimeMillis()) //设置点击行为 .setContentIntent(pendingIntent) //点击后消失 .setAutoCancel(true) //设置声音 .setSound(Uri.fromFile(new File(&quot;/system/media/audio/ringtones/Luna.ogg&quot;))) //设置震动 震动1s 静止1s 震动1s 要申明权限 .setVibrate(new long[]&#123;0, 1000,1000,1000&#125;) //设置呼吸灯闪烁 .setLights(Color.GREEN, 1000, 1000) //设置默认 .setDefaults(NotificationCompat.DEFAULT_ALL) //设置长文本 .setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;An Activity is an application component that provides a screen with which users can interact in order to do something, such as dial the phone, take a photo, send an email, or view a map.&quot;)) //设置展开大图,,设置了长文本会看不到 .setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(),R.mipmap.expensive))) //设置通知重要程度 .setPriority(NotificationCompat.PRIORITY_MAX) .build();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/tags/设计模式/"},{"name":"建造者模式","slug":"建造者模式","permalink":"https://devallever.github.io/tags/建造者模式/"}]},{"title":"Ubuntu server 下配置JDK，Tomcat，MySQL","slug":"build-java-tomcat-mysql","date":"2017-05-16T07:56:38.000Z","updated":"2017-05-20T02:04:06.824Z","comments":true,"path":"2017/05/16/build-java-tomcat-mysql/","link":"","permalink":"https://devallever.github.io/2017/05/16/build-java-tomcat-mysql/","excerpt":"","text":"配置JDK环境 参考：http://blog.csdn.net/yebhweb/article/details/55098189 安装下载好jdk包，如：jdk-8u121-linux-x64.tar.gz为了同一管理安装目录统一为：/opt/复制压缩包到 /opt/jdk目录下进入到 /opt/jdk解压：tar -xvf jdk-8u121-linux-x64.tar.gz删除压缩包 配置jdk环境修改文件进行全局配置1gedit/.bashrc 在最后加入如下内容打开之后在末尾添加1234export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_121 export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 请记住，在上述添加过程中，等号两侧不要加入空格，不然会出现“不是有效的标识符”，因为source /etc/profile 时不能识别多余到空格，会理解为是路径一部分。然后保存。 使配置文件生效1source ~/.bashrc 检验是否安装成功在终端输入如下命令1java -version 安装Tomcat下载压缩包，如：apache-tomcat-8.5.11.tar.gz复制到：/opt/tomcat进入到目录：/opt/tomcat解压：tar -xvf apache-tomcat-8.5.11.tar.gz删除压缩包进入到tomcat安装目录下的bin目录执行：startup.sh就可以启动Tomcat #安装MySQL命令安装1apt install mysql-server-5.7 按提示即可安装完成，并且自动启动MySQL使用root登录mysql1mysql -u root -p 退出：ctrl+z 解决中文乱码修改配置文件1vim /etc/mysql/mysql.conf.d/mysqld.cnf 在[mysqld]中加入如下内容1character-set-server = utf8 重启MySQL：systomctl restart mysql.service启动MySQL：systemctl start mysql.service查看mysql编码1show variables like &apos;character%&apos;; 显示已经改为utf8 创建数据库设置字符集1create database dbname default charset utf8 COLLATE utf8_general_ci; 导入sql文件1source path/filename.sql; 解决MySQL查表大小写问题修改配置文件：/etc/my.cnf 或/etc/mysql/mysql.conf.d/mysqld.cnf在[mysqld]下添加1lower_case_table_names=1 1：表示忽略大小写0：表示不忽略大小写","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://devallever.github.io/categories/Ubuntu/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://devallever.github.io/tags/Tomcat/"},{"name":"MySQL","slug":"MySQL","permalink":"https://devallever.github.io/tags/MySQL/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://devallever.github.io/tags/Ubuntu/"}]},{"title":"","slug":"ScrollMethods","date":"2017-05-15T09:07:15.891Z","updated":"2017-05-15T09:07:15.891Z","comments":true,"path":"2017/05/15/ScrollMethods/","link":"","permalink":"https://devallever.github.io/2017/05/15/ScrollMethods/","excerpt":"","text":"滑动的方式layout()12345678910111213141516171819202122232425@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; //getX()是获取View的坐标 //获取触摸点的坐标 float x = event.getX(); float y = event.getY(); Log.d(TAG, &quot;onTouchEvent: x = &quot; + x); int action = event.getAction(); switch (action)&#123; case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: float movedX = x - lastX; float movedY = y - lastY; Log.d(TAG, &quot;onTouchEvent: lastX = &quot; + lastX); Log.d(TAG, &quot;onTouchEvent: movedX = &quot; + movedX); layout((int)(getLeft()+movedX),(int)(getTop()+movedY),(int)(getRight()+movedX),(int)(getBottom()+movedY)); break; case MotionEvent.ACTION_UP: break; &#125; return true;&#125; Params方式###使用Layout的LayoutParams方式1234LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams)getLayoutParams();layoutParams.leftMargin = (int)(getLeft()+movedX);layoutParams.topMargin = (int)(getTop()+movedY);setLayoutParams(layoutParams); 使用MarginLayoutParams的方式1234ViewGroup.MarginLayoutParams marginLayoutParams = (ViewGroup.MarginLayoutParams)getLayoutParams();marginLayoutParams.leftMargin = (int)(getLeft()+movedX);marginLayoutParams.topMargin = (int)(getTop()+movedY);setLayoutParams(marginLayoutParams); 使用ScrollBy方式12//ScrollBy方式移动的是View里面的内容，如果要移动View则在它的父布局使用scrollBy((View)getParent()).scrollBy(-(int)movedX,-(int)movedY); 使用Scroller平滑移动123456789101112case MotionEvent.ACTION_UP: //使用Scroller平滑移动,手指离开屏幕是View返回原位 int scrollX = ((View)getParent()).getScrollX(); int scrollY = ((View)getParent()).getScrollY(); scroller.startScroll( scrollX, scrollY, -scrollX, -scrollY ); invalidate(); break; 重写computeScroll()方法123456789101112@Overridepublic void computeScroll() &#123; super.computeScroll(); if (scroller.computeScrollOffset())&#123; ((View)getParent()).scrollTo( scroller.getCurrX(), scroller.getCurrY() ); invalidate(); &#125;&#125;","categories":[],"tags":[]},{"title":"设计模式(一) 单例模式","slug":"singleton","date":"2017-05-12T01:40:29.000Z","updated":"2017-05-18T13:32:36.780Z","comments":true,"path":"2017/05/12/singleton/","link":"","permalink":"https://devallever.github.io/2017/05/12/singleton/","excerpt":"","text":"定义确保每个类只存在一个实例，而且自行实例化并向整个系统提供这个实例 使用场景访问IO，数据库，网络等需要消耗多资源的对象 实现方式饿汉模式这家伙太饥饿难耐啦，什么也不干，也不想想在多线程时候怎么保证单例对象的唯一性。 123456789101112public class HungrySingleton &#123; private static final HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125; /**防止反序列化重新构建对象*/ private Object readResolve() throws ObjectStreamException&#123; return hungrySingleton; &#125;&#125; 懒汉模式这家伙懂事点点，考虑到多线程时候怎么保证单例对象的唯一性。就加个synchronized关键字嘛，每次调用该方法都进行同步，但是反应还是有点迟钝。12345678910111213141516public class LazySingleton &#123; private static LazySingleton lazySingleton = null; private LazySingleton()&#123;&#125; /**偷懒！ 只判断一次，造成每次调用该方法都进行同步*/ public static synchronized LazySingleton getInstance()&#123; if (lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125; /**防止反序列化重新构建对象*/ private Object readResolve() throws ObjectStreamException &#123; return lazySingleton; &#125;&#125; 双重检查锁定还是这家伙还是挺老实的，干活不怕苦不怕累，使用了两次判空操作，第一次判空防止不必要的同步，第二次判空保证在null情况下才创建实例。 123456789101112131415161718public class DCLSingleton &#123; private static volatile DCLSingleton dclSingleton = null; private DCLSingleton()&#123;&#125; public static DCLSingleton getInstance()&#123; if (dclSingleton == null)&#123; //避免不必要的同步 synchronized (DCLSingleton.class)&#123; if (dclSingleton == null)&#123; dclSingleton = new DCLSingleton(); &#125; &#125; &#125; return dclSingleton; &#125; /**防止反序列化重新构建对象*/ private Object readResolve() throws ObjectStreamException &#123; return dclSingleton; &#125;&#125; 静态内部类这家伙比较靠谱了，既保证线程安全，也保证单例唯一性，又延迟了单例的实例化，mua1234567891011121314public class StaticInnerSingleton &#123; private StaticInnerSingleton()&#123;&#125; public static StaticInnerSingleton getInstance()&#123; return StaticInnerSingleHolder.staticInnerSingleton; &#125; private static class StaticInnerSingleHolder&#123; private static final StaticInnerSingleton staticInnerSingleton = new StaticInnerSingleton(); &#125; /**防止反序列化重新构建对象*/ private Object readResolve() throws ObjectStreamException &#123; return StaticInnerSingleHolder.staticInnerSingleton; &#125;&#125; 注意事项以上实现方式，在反序列化时候会重新创建对象，所以必须加入以下方法 1234/**防止反序列化重新构建对象*/private Object readResolve() throws ObjectStreamException &#123; return StaticInnerSingleHolder.staticInnerSingleton;&#125; 总结待更新…","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://devallever.github.io/tags/单例模式/"}]},{"title":"设计模式之六大原则","slug":"the-six-principle","date":"2017-05-11T00:50:16.000Z","updated":"2017-05-11T04:20:58.905Z","comments":true,"path":"2017/05/11/the-six-principle/","link":"","permalink":"https://devallever.github.io/2017/05/11/the-six-principle/","excerpt":"","text":"单一职责原则SRP(Single Responsibility Principle)定义: 就一个类而言，应该仅有一个引起它变化的原因。 简单地说： 一个类中应该是一组相关性很高的函数，数据的封装。这满足高内聚的要求 两个完全不一样的功能就不应该放在同一个类中。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/tags/设计模式/"},{"name":"六大原则","slug":"六大原则","permalink":"https://devallever.github.io/tags/六大原则/"}]},{"title":"Java 内部类","slug":"innerclass","date":"2017-05-05T02:26:16.000Z","updated":"2017-05-05T03:20:52.545Z","comments":true,"path":"2017/05/05/innerclass/","link":"","permalink":"https://devallever.github.io/2017/05/05/innerclass/","excerpt":"","text":"内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类 为什么需要内部类？典型的情况是，内部类继承自某个类或实现某个接口，内部类的代码操作创建其的外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。使用内部类最吸引人的原因是：每 个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。如果没有内部类提供的可以继承多 个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实 现了“多重继承”。 静态内部类型(static nested type)静态内部类型可以是class,interface,或者enum。而其他类型的内部类型只能是class。 静态内部类其实还是一个顶层类（源代码文件级别的类），他不依赖外部类,只不过它被封装在另一个class或者interface中，而不是直接定义在文件级别中。因此，它和一般的类静态成员很类似: 1、它不包含外部类当前对象引用this,因此不能直接访问外部类的实际成员,但可以使用外部类的static成员。 2、静态内部类作为一个静态成员,因此可以用访问权限修饰符:public . private …….等。用的最多一般是private 引用静态内部类： Wapper.Inner 3、不能在非静态内部类中再定义静态内部类。静态内部类可以无限深度的嵌套下去。 提升 内部类最终会被javac编译为独立的类，JVM看见的都是top-level类。 编译后的class文件形如：WrapperClass $ InnerStaticClass.class 下面是使用静态内部类简单实现链式栈数据结构的例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class LinkedSatck&lt;E&gt; &#123; private static class Node&lt;T&gt; &#123; public Node(Node&lt;T&gt; next, T data) &#123; this.next = next; this.data = data; &#125; @SuppressWarnings(&quot;unused&quot;) public Node() &#123; this(null, null); &#125; private Node&lt;T&gt; next; private T data; public T getData() &#123; return data; &#125; public Node&lt;T&gt; getNext() &#123; return next; &#125; public boolean isEndNode() &#123; return (next == null); &#125; &#125; public LinkedSatck() &#123; topNode = new Node&lt;E&gt;(null, null); // size =0; &#125; private int size = 0; private Node&lt;E&gt; topNode = null; public void push(E e) &#123; Node&lt;E&gt; newTopNode = new Node&lt;E&gt;(topNode, e); ++size; topNode = newTopNode; &#125; public E pop() &#123; if (topNode.isEndNode()) return null; else &#123; E re = topNode.getData(); topNode = topNode.getNext(); --size; return re; &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; // return topNode.isEnd(); &#125;&#125; 成员内部类(inner member class)成员内部类最重要的特点就是它可以直接使用外部类的实例成员和static成员，即便是使用private修饰也是如此。 因为成员内部类总包含了一个外部类的当前对象引用 ，奇怪的名字 this$0，这个引用在成员内部类实例化时被外部类的当前对象引用this初始化。 大致实现如下：123456789101112class Outter&#123; private class Inner &#123; private final Outter this$0; //javac自动添加 Inner(Outter o) //javac自动添加 &#123; this.this$0 = o; &#125; &#125; //使用成员内部类对象时发生：new Inner(Outter.this)&#125; 这也是为什么在创建一个成员内部类对象时,要先创建一个外部类对象的原因了。 和普通实例成员一样，成员内部里是属于外部类的对象的，那么，在成员内部类就理所当然可以直接使用外部类的其他实例成员以及static成员。 因为是实例成员，所以可以使用访问修饰符:public 、protected、private、和默认的包访问权限。 因为是实例成员，因此，在类的外部使用内部类时，必须先创建1个外部类对象，在实际开发中很少使用这个。 1234567891011121314151617class Outter&#123; public class Inner &#123; &#125;&#125;public class Test &#123;public static void main(String[] args) &#123; Outter out = new Outter(); Outter.Inner in = out.new Inner(); &#125;&#125; 一个例子，自定义一个Str类，来支持迭代。12345678910111213141516171819202122232425262728293031323334353637383940414243class Str implements Iterable&lt;Character&gt;&#123; private String innerStr; public Str(String s) &#123; this.innerStr = (s==null?&quot;&quot;:s); &#125; private class StrIterator implements Iterator&lt;Character&gt; //迭代器类 作为成员内部类 &#123; private int curIndex = 0; @Override public boolean hasNext() &#123; return curIndex &lt; innerStr.length(); //直接访问外部类的成员 innerStr &#125; @Override public Character next() &#123; return innerStr.charAt(curIndex++); //直接访问外部类的成员 innerStr &#125; @Override public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; @Override public Iterator&lt;Character&gt; iterator() &#123; return new StrIterator(); &#125; &#125; 成员内部类中不能有static成员，即不能有static方法 和 static字段（除非static字段修饰为static final，那样的话它只不过是一个符号常量罢了）。因为java中类的静态成员必须定义在一个top-level顶层类中，而成员内部类（包括后面的方法内部类，匿名内部类）不是top-level顶层类。 static成员需要定义在top-level类中，而成员内部类不是top-level类。 提升 JVM是不理解nested类型的，也就是在它看来，所有的类型都是top-level的， 在每一个成员内部类中，javac都会自动添加一个字段：this$0，用来引用外部类当前对象。同时， 内部类的构造函数会自动为这个字段添加一个参数，当构造内部类对象时， 外部类当前对象就会传递给this$0，让这个字段引用外部类当前实例对象。 从这点我们也会发现，为什么要实例化一个成员内部类前，需要先实例化一个外部类对象。因为成员内部包含了一个外部类对象。 编译后的class文件形如：WrapperClass $ InnerClass.class 局部内部类(local inner class)定义在一个方法（包括了类的构造块和static构造块）内部的类，叫局部内部类。它不能有任何访问权限修饰符，因为它只能被包装它的方法使用，离开方法后就不可用了。 局部内部类可以和成员内部类一样，访问外部类的实例成员。同时，它还能直接使用包含它的方法的局部final常量,final参数。javac会复制使用了的外部方法的局部final量保存在局部内部类中作为私有的备份。 因此,当这个外部方法执行完毕后，虽然方法中的局部变量的 lifetime结束了，但是如果局部类的实例作为返回值,它会带着外部方法的局部final量离开这个局部作用域,也就是说,局部变量的生命延长到了和局部内部类的对象的生命周期一致。并不会随着方法执行完立刻被清理掉。我们可以以此来形成闭包。 同样,局部内部类不是top-level类，不能有static成员，除非是static final 字段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Main&#123; public static void main(String[] args) &#123; MsgGenerator g5 = fac(5); System.out.println(g5.generatorMsg()); MsgGenerator g2 = fac(2); System.out.println(g2.generatorMsg()); &#125; public static MsgGenerator fac(final int times) &#123; class Generator implements MsgGenerator &#123; @Override public StringBuffer generatorMsg() &#123; StringBuffer s= new StringBuffer() ; for(int i=0;i&lt;times;++i) &#123; s.append(&quot;hello &quot;); &#125; return s; &#125; &#125; //end of class return new Generator(); //向外发出闭包 &#125; &#125;interface MsgGenerator&#123; StringBuffer generatorMsg();&#125; 提升： 局部内部类之所以能访问外部类的实例成员，其原因和成员内部类是一样的：内部类中有保存了外部类对象的引用。除此之外，局部内部类还能访问包装方法的final字段，javac会将内部类使用了的final 局部常量拷贝到局部内部类中保存，并在局部内部类对象实例化时，初始化这些final常量。因此，局部内部类使用的final常量是自己的拷贝分。 局部内部类的实现原理（模拟） 12345678910111213141516171819202122232425262728293031323334class Wapper&#123; public void wapperFunction() //在方法中定义一个局部类 &#123; final int x = 10; class Local //局部类 &#123; private final int local_copy_x; //假如在局部类中使用了局部常量x，则javac自动生成 private final Wapper this$0; //javac自动生成的字段，用于保存外部类当前对象引用 //首先，局部内部类必定会包含外部类对象，着就是javac插入的第一个构造参数，这是必定的。 //其次，如果我们在局部内部类中使用了包装方法foo中的局部final常量，如x，则会在局部类中 //自动添加隐藏字段local_copy_x，并在构造器中初始化它。 Local(Wapper w,final int x) &#123; this$0 = w; local_copy_x = x; &#125; &#125;//end of Local new Local(); //当实例化局部内部类对象时，等价于 new Local(Wapper.this,x) &#125; &#125; 所以，之所以能在局部内部类中访问外部类的实例，是因为javac自动添加并用外部类当前对象this初始化了局部内部类的字段this$0，这样this$0就引用了外部类当前对象。 局部内部类能使用包装 方法的final字段，也是因为javac自动在局部内部类中添加并初始化的结果。 匿名内部类 (inner anonymous class)匿名内部类是特殊的局部内部类,它没有类名。它的访问特性和局部内类一样。如果只会使用类的一个对象,则可以使用匿名内部类,没有名称避免了再引入一个类名称， 匿名内部类是没有名称的局部内部类，访问特性与局部内部类一样。 因为没有类名,因此只能使用父类名或者接口名来创建对象。 new + superClass 或者 new+interface 。创建对象 是 使用new表达式。 new 表达式:匿名类对象的创建方式是使用new表达式,创建对象的同时也是类结构的编写。表达式的值是一个匿名类对象的引用。 1new SuperClass(param1，param2)&#123; 类体 &#125; 一般来说,匿名类没有构造参数,如果有,则传递给他的父类的构造函数。 匿名内部类由于没有类名，所以你不能定义新的构造函数，只能有默认的构造函数（javac添加的）。补救的做法是使用构造块。 下面是使用swing 中的Timer定时触发回调函数的例子，使用匿名类创建 ActionListener对象。程序每经过1000ms，就会调用 ActionListener对象的actionPerformed方法。 123456789101112131415161718192021222324public static void main(String[] args) &#123; //javax.swing.Timer; Timer t = new Timer(1000, new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; Toolkit.getDefaultToolkit().beep(); //系统响铃声 &#125; &#125; ); t.start(); while(true) &#123; &#125; &#125; 内部类的工作原理内部类只是Java的语法糖，jvm是不理解内部类的，它所看见的都是top-level顶层类。将内部类分离为单独的顶层类，是javac 的任务。内部类被javac合成为单独的类，并形成独立的class文件，这个文件有独特的名称，形式如下： static内部类: OutterClass$InnerClass.class 成员内部类：OutterClass$InnerClass.class 局部内部类: OutterClass$XInnerClass.class # X为一个正整数 局部内部类: OutterClass$X.class # X为一个正整数 对于static内部类，无需多解释，因为 static内部类和外部类是无依赖关系的，static内部类不包含外部类引用，javac只是将他们简单的分离。 成员内部类为什么能访问外部类的成员？因为内部类会被javac自动插入一个字段this&amp;0去保存外部类当前对象this的引用。 1234567891011121314public class OutterClass&#123; private int outFiled = 100; public class InnerClass &#123; public void f() &#123; int i = outFiled; &#125; &#125;&#125; javap反编译后的结果12345678910111213141516171819202122232425Compiled from &quot;OutterClass.java&quot;public class OutterClass$InnerClass &#123; final OutterClass this$0; //由javac自动合成：内部类包含1个外部类的当前对象的引用this&amp;0，使用this&amp;0避免和this冲突 //javac自动合成：合成的构造函数，有1个外部类参数，用于初始化 this&amp;0，this&amp;0被赋值为OutterClass.this public OutterClass$InnerClass(OutterClass); Code: 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LOutterClass; 5: aload_0 6: invokespecial #2 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: return public void f(); Code: 0: aload_0 1: getfield #1 // Field this$0:LOutterClass; 4: invokestatic #3 // Method OutterClass.access$000:(LOutterClass;)I 7: istore_1 8: return &#125; 局部内部类和匿名内部类除了可以访问外部类的成员（原因和成员内部类是相同的），还可以访问外部方法的局部final量和final参数。原因如下： A local class can use local variables because javac automatically gives the class aprivate instance field to hold a copy of each local variable the class uses.The compiler also adds hidden parameters to each local class constructor to initial‐ize these automatically created private fields. A local class does not actually accesslocal variables but merely its own private copies of them. This could cause inconsis‐tencies if the local variables could alter outside of the local class. -- 《Java int a Nutshell》 因为javac会自动在（局部和匿名）内部类中插入私有 的实例字段来保存 使用了的外部方法的final量的拷贝。javac还会在（局部和匿名）内部类中的构造函数的添加参数来初始化插入的私有 的字段。所以，（局部和匿名）内部类使用的实质是自己获得的拷贝量，而不是直接使用外部方法的final量。如果外部方法的量不修饰为final的话，那么意味着它的值可以改变，这就可能会导致（局部和匿名）内部类中获得的拷贝和外部方法不一致。所以java强制要求只能使用final量。 静态内部类和非静态内部类的区别如果你不需要内部类对象与其外围类对象之间有联系，那你可以将内部类声明为static。这通常称为嵌套类（nested class）。Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。想要理解static应用于内部类时的含义，你就必须记住，普通的内部类对象隐含地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时，就不是这样了。嵌套类意味着： 嵌套类的对象，并不需要其外围类的对象。 不能从嵌套类的对象中访问非静态的外围类对象。 123456789101112131415161718192021222324252627282930313233343536373839public class StaticTest&#123; private static String name = &quot;woobo&quot;; private String num = &quot;X001&quot;; static class Person&#123; // 静态内部类可以用public,protected,private修饰 // 静态内部类中可以定义静态或者非静态的成员 private String address = &quot;China&quot;;Private Static String x=“as”; public String mail = &quot;kongbowoo@yahoo.com.cn&quot;;//内部类公有成员 public void display()&#123; //System.out.println(num);//不能直接访问外部类的非静态成员// 静态内部类不能访问外部类的非静态成员(包括非静态变量和非静态方法) System.out.println(name);//只能直接访问外部类的静态成员//静态内部类只能访问外部类的静态成员(包括静态变量和静态方法) System.out.println(&quot;Inner &quot; + address);//访问本内部类成员。 &#125; &#125; public void printInfo()&#123; Person person = new Person();// 外部类访问内部类的非静态成员:实例化内部类即可 person.display(); //System.out.println(mail);//不可访问 //System.out.println(address);//不可访问 System.out.println(person.address);//可以访问内部类的私有成员System.out.println(Person.x);// 外部类访问内部类的静态成员：内部类.静态成员 System.out.println(person.mail);//可以访问内部类的公有成员 &#125; public static void main(String[] args)&#123; StaticTest staticTest = new StaticTest(); staticTest.printInfo(); &#125;&#125; 在静态嵌套类内部, 不能访问外部类的非静态成员, 这是由Java语法中”静态方法不能直接访问非静态成员”所限定.注意, 外部类访问内部类的的成员有些特别, 不能直接访问, 但可以通过内部类实例来访问, 这是因为静态嵌套内的所有成员和方法默认为静态的了.同时注意, 内部静态类Person只在类StaticTest 范围内可见, 若在其它类中引用或初始化, 均是错误的.一 . 静态内部类可以有静态成员，而非静态内部类则不能有静态成员。二 . 静态内部类的非静态成员可以访问外部类的静态变量，而不可访问外部类的非静态变量； 三 . 非静态内部类的非静态成员可以访问外部类的非静态变量。 生成一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成：Outer.Inner in = new Outer.Inner();而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类(正常情况下，你不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分，因为它是static 的。只是将嵌套类置于接口的命名空间内，这并不违反接口的规则） 原文地址：http://www.cnblogs.com/WuXuanKun/p/6220964.html","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"内部类","slug":"内部类","permalink":"https://devallever.github.io/tags/内部类/"}]},{"title":"滚动屏幕自动隐藏FloatingActionButton","slug":"fab-auto-hideshow","date":"2017-04-24T01:56:01.000Z","updated":"2017-04-24T03:50:43.817Z","comments":true,"path":"2017/04/24/fab-auto-hideshow/","link":"","permalink":"https://devallever.github.io/2017/04/24/fab-auto-hideshow/","excerpt":"","text":"概述FloatingActionButton可以说是Material Design 的标志之一了，但是却有很多人并不是很喜欢它，其中一条主要的原因就是FAB的存在挡住了要显示的内容，从而影响体验。本文主要介绍对FAB两方面的优化，一方面是点击FAB弹出子菜单的特效，一方面是在滑动时自动隐藏FAB。最终的实现 原理 它的显示与隐藏是根据AppBarLayout的Y值来决定的，我们知道如果按照最上面的方式定义主界面布局，列表滚动的时候toolbar会显示和隐藏，而toolbar是AppBarLayout的一部分，因此可以让Behavior依赖于AppBarLayout，当AppBarLayout变化的时候会调用onDependentViewChanged，然后在这里获取AppBarLayout的高度移动的距离，然后根据这个距离来判定FloatingActionButton上下移动的距离，从而实现了FloatingActionButton的显示和隐藏。这个实现方式我是在这里找到的： http://stackoverflow.com/questions/31457099/android-fab-to-hide-when-navigating-between-different-fragments-in-a-viewpager 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class FABVerticalBehavior extends FloatingActionButton.Behavior &#123; private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator(); private boolean mIsAnimatingOut = false; public FABVerticalBehavior(Context context, AttributeSet attrs) &#123; super(); &#125; @Override public boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View directTargetChild, final View target, final int nestedScrollAxes) &#123; // Ensure we react to vertical scrolling return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); &#125; @Override public void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0 &amp;&amp; !this.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123; // User scrolled down and the FAB is currently visible -&gt; hide the FAB animateOut(child); &#125; else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; // User scrolled up and the FAB is currently not visible -&gt; show the FAB animateIn(child); &#125; &#125; // Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exits private void animateOut(final FloatingActionButton button) &#123; if (Build.VERSION.SDK_INT &gt;= 14) &#123; ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer() .setListener(new ViewPropertyAnimatorListener() &#123; public void onAnimationStart(View view) &#123; FABVerticalBehavior.this.mIsAnimatingOut = true; &#125; public void onAnimationCancel(View view) &#123; FABVerticalBehavior.this.mIsAnimatingOut = false; &#125; public void onAnimationEnd(View view) &#123; FABVerticalBehavior.this.mIsAnimatingOut = false; view.setVisibility(View.GONE); &#125; &#125;).start(); &#125; else &#123; &#125; &#125; // Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout enters private void animateIn(FloatingActionButton button) &#123; button.setVisibility(View.VISIBLE); if (Build.VERSION.SDK_INT &gt;= 14) &#123; ViewCompat.animate(button).translationY(0) .setInterpolator(INTERPOLATOR).withLayer().setListener(null) .start(); &#125; else &#123; &#125; &#125; private int getMarginBottom(View v) &#123; int marginBottom = 0; final ViewGroup.LayoutParams layoutParams = v.getLayoutParams(); if (layoutParams instanceof ViewGroup.MarginLayoutParams) &#123; marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin; &#125; return marginBottom; &#125;&#125; 注意 在25.0.1以上版本的design包中，会有隐藏后不显示的Bug 参考这里","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"}]},{"title":"Android 应用开发所需的技能和自我评分","slug":"android-developer-base-skill-20","date":"2017-04-23T02:22:57.000Z","updated":"2017-04-23T02:57:07.828Z","comments":true,"path":"2017/04/23/android-developer-base-skill-20/","link":"","permalink":"https://devallever.github.io/2017/04/23/android-developer-base-skill-20/","excerpt":"","text":"Android 应用开发所需的技能和自我评分 参考: App研发录 评分标准每个技能点都是五分制 完全不知道:0分 听说过:1分 看过相关文章:2分 做过demo:3分 项目中使用过:4分 非常熟悉:5分 技能 描述 得分(4月23日) Activity相关 launchModel, onSaveInstanceState, 生命周期 3 Fragment相关 3 序列化技术 前者基于Service, 后者基于Bundle 1 ImageLoader原理与实现 Parcelable和Serialiable 1 fastJSO和GSON 4 多线程 Handler, Looper, ExecuteService等 3 Adapter和RecyclerView 3 Cookie 登录机制, HttpRequest夹带Cookie进行身份验证 3 网络请求封装 使用AsyncTask, 使用Handler+Runnable 1 Android与HTML5的交互 Android调用HTML5 和 HTML5调用Android 1 代码混淆 proGuard 1 打包机制 Android sdk 命令, 打包过程, Ant 或 Gradle 或 Maven 0 线上Crash分析和修复 分析Crash信息修复线上 Crash 0 内存泄漏 内存优化, 内存泄露, MAT 1 调试工具 DDMS 2 Monkey机制 Monkey测试 0 单元测试 JUnit 1 Git 2 插件化编程 DexClassLoader 0 设计模式 工厂, 生成器, 适配器, 代理, 策略, 观察者, 单例等 2","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"}]},{"title":"Material Design 笔记","slug":"material-design-note","date":"2017-04-21T14:08:13.000Z","updated":"2017-04-21T14:13:12.622Z","comments":true,"path":"2017/04/21/material-design-note/","link":"","permalink":"https://devallever.github.io/2017/04/21/material-design-note/","excerpt":"","text":"1.Toolbar的使用1.1设置应用的主题为NoActionBar1android:theme=&quot;@style/AppTheme&quot; 这个主题在sytle文件中定义123456&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;&lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorGreen_300&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorGreen700&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 1.2在布局文件中使用Toolbar控件1234567&lt;android.support.v7.widget.Toolbarandroid:id=&quot;@+id/id_material_design_activity_toolbar&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;?actionBarSize&quot;android:background=&quot;@color/colorGreen700&quot;android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; 1.3在Activity中这样用12Toolbar toolbar = (Toolbar)findViewById(R.id.id_material_design_activity_toolbar);setSupportActionBar(toolbar); 1.4设置toolbar的home图标并设置监听12345ActionBar actionBar = getSupportActionBar();if (actionBar != null)&#123;actionBar.setDisplayHomeAsUpEnabled(true);actionBar.setHomeAsUpIndicator(R.mipmap.ic_arrow_back_white_36dp);&#125; 在onOptionsItemSelected()方法中设置监听123case android.R.id.home:drawerLayout.openDrawer(GravityCompat.START);break; 1.5设置toolbar菜单1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/id_menu_notification&quot; android:title=&quot;Notification&quot; android:icon=&quot;@mipmap/ic_notifications_active_white_24dp&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/id_menu_sms&quot; android:title=&quot;Notification&quot; android:icon=&quot;@mipmap/ic_sms_white_24dp&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/id_menu_person&quot; android:title=&quot;Notification&quot; android:icon=&quot;@mipmap/ic_person_outline_white_24dp&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;/menu&gt; 然后在Activity中加载这个菜单 1234567891011121314151617181920212223242526@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar_menu,menu); return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); switch (id)&#123; case R.id.id_menu_notification: Toast.makeText(this,&quot;Notification&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_menu_sms: Toast.makeText(this,&quot;SMS&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_menu_person: Toast.makeText(this,&quot;Contacts&quot;,Toast.LENGTH_SHORT).show(); break; case android.R.id.home: drawerLayout.openDrawer(GravityCompat.START); break; &#125; return true;&#125; 2.DrawerLayout与NavigationView的爱恨情仇2.1在布局中使用DrawerLayout和NavigationView1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/id_material_design_activity_drawer_layout&quot;&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/id_material_design_activity_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?actionBarSize&quot; android:background=&quot;@color/colorGreen700&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/id_material_design_activity_fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/ic_notifications_active_white_24dp&quot; app:elevation=&quot;8dp&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/id_material_design_navigation_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:menu=&quot;@menu/nav_menu&quot; app:headerLayout=&quot;@layout/nav_header_layout&quot;/&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; 其中NavigationVIew包含一个menu菜单和头布局nav_menu.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/id_nav_menu_item_like&quot; android:icon=&quot;@mipmap/ic_favorite_black_24dp&quot; android:title=&quot;Like&quot;/&gt; &lt;item android:id=&quot;@+id/id_nav_menu_item_alarm&quot; android:icon=&quot;@mipmap/ic_alarm_black_24dp&quot; android:title=&quot;Alarm&quot;/&gt; &lt;item android:id=&quot;@+id/id_nav_menu_item_account&quot; android:icon=&quot;@mipmap/ic_account_circle_black_24dp&quot; android:title=&quot;Account&quot;/&gt; &lt;item android:id=&quot;@+id/id_nav_menu_item_setting&quot; android:icon=&quot;@mipmap/ic_build_black_24dp&quot; android:title=&quot;Setting&quot;/&gt; &lt;/group&gt; &lt;/menu&gt; nav_header_layout1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; android:padding=&quot;10dp&quot; android:background=&quot;@color/colorGreen700&quot;&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id=&quot;@+id/id_nav_header_iv_head&quot; android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:src=&quot;@mipmap/h_01&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;TextView android:id=&quot;@+id/id_nav_header_tv_email&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;devallever@163.com&quot; android:textColor=&quot;@color/white&quot; android:layout_alignParentBottom=&quot;true&quot;/&gt; &lt;TextView android:id=&quot;@+id/id_nav_header_tv_username&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;5dp&quot; android:text=&quot;Devallever&quot; android:textColor=&quot;@color/white&quot; android:layout_above=&quot;@id/id_nav_header_tv_email&quot;/&gt; &lt;/RelativeLayout&gt; 2.2设置NavigationView的菜单监听1234567891011121314151617181920212223navigationView = (NavigationView)findViewById(R.id.id_material_design_navigation_view);navigationView.setCheckedItem(R.id.id_nav_menu_item_like);navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; int id = item.getItemId(); switch (id)&#123; case R.id.id_nav_menu_item_like: Toast.makeText(MaterialDesignActivity.this, &quot;Like&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_nav_menu_item_account: Toast.makeText(MaterialDesignActivity.this, &quot;Account&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_nav_menu_item_alarm: Toast.makeText(MaterialDesignActivity.this, &quot;Alarm&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_nav_menu_item_setting: Toast.makeText(MaterialDesignActivity.this, &quot;Setting&quot;,Toast.LENGTH_SHORT).show(); break; &#125; return true; &#125;&#125;); 2.3把toolbar与NavigationView关联起来，并实现home的动画效果123ActionBarDrawerToggle actionBarDrawerToggle = new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.app_name, R.string.app_name);actionBarDrawerToggle.syncState(); 3FloatActionButton3.1在布局中使用FloatActionButton控件12345678&lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/id_material_design_activity_fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/ic_notifications_active_white_24dp&quot; app:elevation=&quot;8dp&quot;/&gt; 3.2设置监听，和一般的按钮设置监听是一样的123456fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 4Snackbar当点击按钮时候弹出Snackbar12345678910111213fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v, &quot;Remind!&quot;, Snackbar.LENGTH_INDEFINITE) .setAction(&quot;I know.&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MaterialDesignActivity.this,&quot;OK&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;) .show(); &#125;&#125;); 5CoordinatorLayout加强版的FrameLayout123456789101112131415161718192021&lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/id_material_design_activity_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?actionBarSize&quot; android:background=&quot;@color/colorGreen700&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/id_material_design_activity_fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/ic_notifications_active_white_24dp&quot; app:elevation=&quot;8dp&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Material Design","slug":"Material-Design","permalink":"https://devallever.github.io/tags/Material-Design/"}]},{"title":"Markdown 教程","slug":"markdown-learn","date":"2017-04-21T08:32:17.000Z","updated":"2017-04-21T09:20:44.418Z","comments":true,"path":"2017/04/21/markdown-learn/","link":"","permalink":"https://devallever.github.io/2017/04/21/markdown-learn/","excerpt":"","text":"『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』 原文地址 Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 和 * 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： 我的头像 Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://devallever.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://devallever.github.io/tags/Markdown/"}]},{"title":"Java连接数据库","slug":"Java连接数据库","date":"2017-04-21T05:49:27.000Z","updated":"2017-04-21T09:20:14.465Z","comments":true,"path":"2017/04/21/Java连接数据库/","link":"","permalink":"https://devallever.github.io/2017/04/21/Java连接数据库/","excerpt":"","text":"MySQL provides standards-based drivers for JDBC, ODBC, and .Net enabling developers to build database applications in their language of choice. In addition, a native C library allows developers to embed MySQL directly into their applications. 1.下载相关的驱动程序如 Java与MySQL的连接,可到MySQL官网上下载下载地址 2.数据库的URL格式如: jdbc:mysql://127.0.0.1/dbname在连接数据库时,我们必须使用各种与数据库类型相关的参数,例如主机名,端口号和数据库名jdbc的一般语法:jdbc:subprotocol:other stuff subprotocol:连接数据库的具体驱动程序 other stuff:随subprotocol的不同而不同,应查阅供应商的相关文档 3.注册驱动器类1Class.forName(\"com.mysql.jdbc.Driver\"); 字符串的内容为驱动器类所在包的全路径这条语句使得驱动器类被加载,由此将执行可以注册驱动器的静态初始化器 4.连接到数据库1Connection conn = DriverManager.getConnection(sqlUrl, username, password); 以上三个参数类型都是字符串类型, 连接成功会返回Connection对象,用它去执行SQL语句. 5.操作数据库5.1 基本方法1String sql = \"select nickname, phone from tuser where username='xm'\"; 执行sql命令首先创建Statement对象或其子类PreparedStatement对象12345statement = conn.createStatement();preparedStatement = conn.preparedStatement(sql);ResultSet resultSet = statement.executeQuery(sql);或resultSet = preparedStatement.executeQuery(); executeQuery()方法可以执行select 语句, executeUpdate()方法可以执行insert, update和delete之类的操作. 也可以执行create table 和drop table之类的数据定义语句. execute()方法可以执行任意的sql语句.","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://devallever.github.io/tags/java/"},{"name":"sql","slug":"sql","permalink":"https://devallever.github.io/tags/sql/"}]},{"title":"Hello Android","slug":"helloAndroid","date":"2017-04-17T14:56:05.454Z","updated":"2017-04-17T14:56:05.438Z","comments":true,"path":"2017/04/17/helloAndroid/","link":"","permalink":"https://devallever.github.io/2017/04/17/helloAndroid/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-04-17T08:48:22.843Z","updated":"2017-04-17T08:48:22.843Z","comments":true,"path":"2017/04/17/hello-world/","link":"","permalink":"https://devallever.github.io/2017/04/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"179. HttpUrlConnection","slug":"179-android-java-http-url-connection","date":"2016-07-15T06:59:51.000Z","updated":"2017-07-15T07:17:22.947Z","comments":true,"path":"2016/07/15/179-android-java-http-url-connection/","link":"","permalink":"https://devallever.github.io/2016/07/15/179-android-java-http-url-connection/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"HttpUrlConnection","slug":"HttpUrlConnection","permalink":"https://devallever.github.io/tags/HttpUrlConnection/"}]},{"title":"176. Java 同步","slug":"176-java-async","date":"2016-07-15T06:56:39.000Z","updated":"2017-07-15T07:17:11.658Z","comments":true,"path":"2016/07/15/176-java-async/","link":"","permalink":"https://devallever.github.io/2016/07/15/176-java-async/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"Async","slug":"Async","permalink":"https://devallever.github.io/tags/Async/"}]},{"title":"174. Java 多线程","slug":"174-java-thread","date":"2016-07-15T06:55:11.000Z","updated":"2017-07-15T07:17:03.434Z","comments":true,"path":"2016/07/15/174-java-thread/","link":"","permalink":"https://devallever.github.io/2016/07/15/174-java-thread/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"https://devallever.github.io/tags/Thread/"}]},{"title":"173. 第一行代码 第八章 多媒体 音频视频 笔记","slug":"173-first-code-android-chapter-8-note-media","date":"2016-07-15T06:53:30.000Z","updated":"2017-07-15T06:54:42.677Z","comments":true,"path":"2016/07/15/173-first-code-android-chapter-8-note-media/","link":"","permalink":"https://devallever.github.io/2016/07/15/173-first-code-android-chapter-8-note-media/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"Media","slug":"Media","permalink":"https://devallever.github.io/tags/Media/"}]},{"title":"170. Java 异常","slug":"170-java-exception","date":"2016-07-15T06:51:11.000Z","updated":"2017-07-15T07:16:51.090Z","comments":true,"path":"2016/07/15/170-java-exception/","link":"","permalink":"https://devallever.github.io/2016/07/15/170-java-exception/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"Exception","slug":"Exception","permalink":"https://devallever.github.io/tags/Exception/"}]},{"title":"167. 第一行代码 第八章 多媒体 选择图片 笔记","slug":"167-first-code-android-chapter-8-note-choose-pic","date":"2016-07-15T06:47:12.000Z","updated":"2017-07-15T07:03:16.355Z","comments":true,"path":"2016/07/15/167-first-code-android-chapter-8-note-choose-pic/","link":"","permalink":"https://devallever.github.io/2016/07/15/167-first-code-android-chapter-8-note-choose-pic/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"PictureChooser","slug":"PictureChooser","permalink":"https://devallever.github.io/tags/PictureChooser/"}]},{"title":"165-first-code-android-chapter-8-note-camera 笔记","slug":"165-first-code-android-chapter-8-note-camera","date":"2016-07-15T06:40:12.000Z","updated":"2017-07-15T07:03:30.743Z","comments":true,"path":"2016/07/15/165-first-code-android-chapter-8-note-camera/","link":"","permalink":"https://devallever.github.io/2016/07/15/165-first-code-android-chapter-8-note-camera/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"Camera","slug":"Camera","permalink":"https://devallever.github.io/tags/Camera/"}]},{"title":"163. 第一行代码 第八章 多媒体 Notification 笔记","slug":"163-first-code-android-chapter-8-note-notification","date":"2016-07-15T06:28:58.000Z","updated":"2017-07-15T06:30:47.612Z","comments":true,"path":"2016/07/15/163-first-code-android-chapter-8-note-notification/","link":"","permalink":"https://devallever.github.io/2016/07/15/163-first-code-android-chapter-8-note-notification/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"Notification","slug":"Notification","permalink":"https://devallever.github.io/tags/Notification/"}]},{"title":"161. 第一行代码 第六章 持久化 LitePal 笔记","slug":"161-first-code-android-chapter-6-note-litepal","date":"2016-07-15T06:25:02.000Z","updated":"2017-07-15T06:27:59.295Z","comments":true,"path":"2016/07/15/161-first-code-android-chapter-6-note-litepal/","link":"","permalink":"https://devallever.github.io/2016/07/15/161-first-code-android-chapter-6-note-litepal/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"LitePal","slug":"LitePal","permalink":"https://devallever.github.io/tags/LitePal/"}]},{"title":"159. List Set Map","slug":"159-java-list-set-map","date":"2016-07-15T06:22:33.000Z","updated":"2017-07-15T07:16:30.733Z","comments":true,"path":"2016/07/15/159-java-list-set-map/","link":"","permalink":"https://devallever.github.io/2016/07/15/159-java-list-set-map/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"List","slug":"List","permalink":"https://devallever.github.io/tags/List/"},{"name":"Set","slug":"Set","permalink":"https://devallever.github.io/tags/Set/"},{"name":"Map","slug":"Map","permalink":"https://devallever.github.io/tags/Map/"}]},{"title":"157. 第一行代码 第六章 持久化 Sqlite 笔记","slug":"157-first-code-android-chapter-6-note-sqlite","date":"2016-07-15T06:18:41.000Z","updated":"2017-07-15T06:20:20.121Z","comments":true,"path":"2016/07/15/157-first-code-android-chapter-6-note-sqlite/","link":"","permalink":"https://devallever.github.io/2016/07/15/157-first-code-android-chapter-6-note-sqlite/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"Sqlite","slug":"Sqlite","permalink":"https://devallever.github.io/tags/Sqlite/"}]},{"title":"155. Java 内部类","slug":"155-java-inner-class","date":"2016-07-15T06:16:22.000Z","updated":"2017-07-15T07:16:21.965Z","comments":true,"path":"2016/07/15/155-java-inner-class/","link":"","permalink":"https://devallever.github.io/2016/07/15/155-java-inner-class/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"Inner Class","slug":"Inner-Class","permalink":"https://devallever.github.io/tags/Inner-Class/"}]},{"title":"152. 面向对象基本概念","slug":"152-java-oop-concept","date":"2016-07-15T06:14:28.000Z","updated":"2017-07-15T07:16:14.633Z","comments":true,"path":"2016/07/15/152-java-oop-concept/","link":"","permalink":"https://devallever.github.io/2016/07/15/152-java-oop-concept/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"OOP","slug":"OOP","permalink":"https://devallever.github.io/tags/OOP/"}]},{"title":"151. 第一行代码 第六章 持久化 SharePreferences 笔记","slug":"151-first-code-android-chapter-6-note-share-preferences","date":"2016-07-15T06:10:52.000Z","updated":"2017-07-15T06:20:33.185Z","comments":true,"path":"2016/07/15/151-first-code-android-chapter-6-note-share-preferences/","link":"","permalink":"https://devallever.github.io/2016/07/15/151-first-code-android-chapter-6-note-share-preferences/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"SharePreferences","slug":"SharePreferences","permalink":"https://devallever.github.io/tags/SharePreferences/"}]},{"title":"150. 第一行代码 第六章 持久化 File 笔记","slug":"150-first-code-android-chapter-6-note-file","date":"2016-07-15T06:07:20.000Z","updated":"2017-07-15T06:20:44.841Z","comments":true,"path":"2016/07/15/150-first-code-android-chapter-6-note-file/","link":"","permalink":"https://devallever.github.io/2016/07/15/150-first-code-android-chapter-6-note-file/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"File","slug":"File","permalink":"https://devallever.github.io/tags/File/"}]},{"title":"147. Java常用类","slug":"147-java-basic-common-class","date":"2016-07-15T06:04:24.000Z","updated":"2017-07-15T07:15:59.637Z","comments":true,"path":"2016/07/15/147-java-basic-common-class/","link":"","permalink":"https://devallever.github.io/2016/07/15/147-java-basic-common-class/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"}]},{"title":"145. Java 基础","slug":"145-java-basic","date":"2016-07-15T06:02:13.000Z","updated":"2017-07-15T07:15:37.124Z","comments":true,"path":"2016/07/15/145-java-basic/","link":"","permalink":"https://devallever.github.io/2016/07/15/145-java-basic/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"}]},{"title":"143. 第一行代码 第五章 Broadcast Receiver 笔记","slug":"143-first-code-android-chapter-5-note-broadcast-receiver","date":"2016-07-15T03:57:33.000Z","updated":"2017-07-15T03:58:53.967Z","comments":true,"path":"2016/07/15/143-first-code-android-chapter-5-note-broadcast-receiver/","link":"","permalink":"https://devallever.github.io/2016/07/15/143-first-code-android-chapter-5-note-broadcast-receiver/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"Broadcast Reveiver","slug":"Broadcast-Reveiver","permalink":"https://devallever.github.io/tags/Broadcast-Reveiver/"}]},{"title":"141. 第一行代码 第四章 Fragment 笔记","slug":"141-first-code-android-chapter-4-note-fragment","date":"2016-07-15T03:55:06.000Z","updated":"2017-07-15T03:56:25.367Z","comments":true,"path":"2016/07/15/141-first-code-android-chapter-4-note-fragment/","link":"","permalink":"https://devallever.github.io/2016/07/15/141-first-code-android-chapter-4-note-fragment/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"Fragment","slug":"Fragment","permalink":"https://devallever.github.io/tags/Fragment/"}]},{"title":"140. 第一行代码 第三章 UI 笔记","slug":"140-first-code-android-chapter-3-note-ui","date":"2016-07-15T03:53:30.000Z","updated":"2017-07-15T03:54:30.240Z","comments":true,"path":"2016/07/15/140-first-code-android-chapter-3-note-ui/","link":"","permalink":"https://devallever.github.io/2016/07/15/140-first-code-android-chapter-3-note-ui/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"UI","slug":"UI","permalink":"https://devallever.github.io/tags/UI/"}]},{"title":"135. 第一行代码 第二章 Activity 笔记","slug":"135-first-code-android-chapter-2-note-activity","date":"2016-07-15T03:51:29.000Z","updated":"2017-07-15T03:52:52.754Z","comments":true,"path":"2016/07/15/135-first-code-android-chapter-2-note-activity/","link":"","permalink":"https://devallever.github.io/2016/07/15/135-first-code-android-chapter-2-note-activity/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"Activity","slug":"Activity","permalink":"https://devallever.github.io/tags/Activity/"}]},{"title":"133. 第一行代码 第一章 Android架构 笔记","slug":"133-first-code-android-chapter-1-note","date":"2016-07-15T03:48:53.000Z","updated":"2017-07-15T03:50:54.715Z","comments":true,"path":"2016/07/15/133-first-code-android-chapter-1-note/","link":"","permalink":"https://devallever.github.io/2016/07/15/133-first-code-android-chapter-1-note/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"FirstCode","slug":"FirstCode","permalink":"https://devallever.github.io/tags/FirstCode/"},{"name":"Framework","slug":"Framework","permalink":"https://devallever.github.io/tags/Framework/"}]},{"title":"123.Retrofit 基本使用","slug":"123-retrofit-2-basic-using","date":"2016-07-15T03:44:59.000Z","updated":"2017-07-15T03:46:36.347Z","comments":true,"path":"2016/07/15/123-retrofit-2-basic-using/","link":"","permalink":"https://devallever.github.io/2016/07/15/123-retrofit-2-basic-using/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Retrofit","slug":"Retrofit","permalink":"https://devallever.github.io/tags/Retrofit/"}]},{"title":"112.属性动画基本使用","slug":"112-property-animation-basic-using","date":"2016-07-15T03:41:55.000Z","updated":"2017-07-15T03:43:50.106Z","comments":true,"path":"2016/07/15/112-property-animation-basic-using/","link":"","permalink":"https://devallever.github.io/2016/07/15/112-property-animation-basic-using/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Animation","slug":"Animation","permalink":"https://devallever.github.io/tags/Animation/"}]},{"title":"111-toolbar-basic-using","slug":"111-toolbar-basic-using","date":"2016-07-15T03:40:37.000Z","updated":"2017-07-15T03:47:32.237Z","comments":true,"path":"2016/07/15/111-toolbar-basic-using/","link":"","permalink":"https://devallever.github.io/2016/07/15/111-toolbar-basic-using/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Toolbar","slug":"Toolbar","permalink":"https://devallever.github.io/tags/Toolbar/"}]},{"title":"108.ListView 简单使用","slug":"108-listview-basic-using","date":"2016-07-15T03:37:45.000Z","updated":"2017-07-15T03:47:23.809Z","comments":true,"path":"2016/07/15/108-listview-basic-using/","link":"","permalink":"https://devallever.github.io/2016/07/15/108-listview-basic-using/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"ListView","slug":"ListView","permalink":"https://devallever.github.io/tags/ListView/"}]},{"title":"107.ViewPager 简单使用","slug":"107-viewpager-basic-using","date":"2016-07-15T03:36:04.000Z","updated":"2017-07-15T03:47:10.660Z","comments":true,"path":"2016/07/15/107-viewpager-basic-using/","link":"","permalink":"https://devallever.github.io/2016/07/15/107-viewpager-basic-using/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"ViewPager","slug":"ViewPager","permalink":"https://devallever.github.io/tags/ViewPager/"}]},{"title":"105.RecyclerView简单使用","slug":"105-recyclerview-basic-using","date":"2016-07-15T03:32:09.000Z","updated":"2017-07-15T03:47:03.952Z","comments":true,"path":"2016/07/15/105-recyclerview-basic-using/","link":"","permalink":"https://devallever.github.io/2016/07/15/105-recyclerview-basic-using/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://devallever.github.io/tags/RecyclerView/"}]},{"title":"104.自学到什么程度才能找到工作","slug":"104-self-study-in-android-to-find-job","date":"2016-07-15T03:18:18.000Z","updated":"2017-07-15T03:30:35.123Z","comments":true,"path":"2016/07/15/104-self-study-in-android-to-find-job/","link":"","permalink":"https://devallever.github.io/2016/07/15/104-self-study-in-android-to-find-job/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"}]},{"title":"102.MVC在Android中的应用","slug":"102-mvc-in-android","date":"2016-07-14T13:56:38.000Z","updated":"2017-07-15T03:46:53.080Z","comments":true,"path":"2016/07/14/102-mvc-in-android/","link":"","permalink":"https://devallever.github.io/2016/07/14/102-mvc-in-android/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"MVC","slug":"MVC","permalink":"https://devallever.github.io/tags/MVC/"}]},{"title":"101.Android 选择适当的网络请求框架","slug":"101-choose-network-framework","date":"2016-07-14T13:52:12.000Z","updated":"2017-07-15T03:16:24.730Z","comments":true,"path":"2016/07/14/101-choose-network-framework/","link":"","permalink":"https://devallever.github.io/2016/07/14/101-choose-network-framework/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"NoteBook1","slug":"NoteBook1","permalink":"https://devallever.github.io/tags/NoteBook1/"},{"name":"Network","slug":"Network","permalink":"https://devallever.github.io/tags/Network/"}]}]}