{"meta":{"title":"Allever Blog","subtitle":"Android Developer","description":"Android Developer","author":"Allever","url":"https://devallever.github.io"},"pages":[{"title":"","date":"2017-04-21T08:42:35.918Z","updated":"2017-04-21T08:42:35.918Z","comments":false,"path":"categories/index.html","permalink":"https://devallever.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-21T08:41:34.775Z","updated":"2017-04-21T08:41:34.775Z","comments":false,"path":"tags/index.html","permalink":"https://devallever.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式之六大原则","slug":"the-six-principle","date":"2017-05-11T00:50:16.000Z","updated":"2017-05-11T04:20:58.905Z","comments":true,"path":"2017/05/11/the-six-principle/","link":"","permalink":"https://devallever.github.io/2017/05/11/the-six-principle/","excerpt":"","text":"单一职责原则SRP(Single Responsibility Principle)定义: 就一个类而言，应该仅有一个引起它变化的原因。 简单地说： 一个类中应该是一组相关性很高的函数，数据的封装。这满足高内聚的要求 两个完全不一样的功能就不应该放在同一个类中。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://devallever.github.io/tags/设计模式/"},{"name":"六大原则","slug":"六大原则","permalink":"https://devallever.github.io/tags/六大原则/"}]},{"title":"Java 内部类","slug":"innerclass","date":"2017-05-05T02:26:16.000Z","updated":"2017-05-05T03:20:52.545Z","comments":true,"path":"2017/05/05/innerclass/","link":"","permalink":"https://devallever.github.io/2017/05/05/innerclass/","excerpt":"","text":"内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类 为什么需要内部类？典型的情况是，内部类继承自某个类或实现某个接口，内部类的代码操作创建其的外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。使用内部类最吸引人的原因是：每 个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。如果没有内部类提供的可以继承多 个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实 现了“多重继承”。 静态内部类型(static nested type)静态内部类型可以是class,interface,或者enum。而其他类型的内部类型只能是class。 静态内部类其实还是一个顶层类（源代码文件级别的类），他不依赖外部类,只不过它被封装在另一个class或者interface中，而不是直接定义在文件级别中。因此，它和一般的类静态成员很类似: 1、它不包含外部类当前对象引用this,因此不能直接访问外部类的实际成员,但可以使用外部类的static成员。 2、静态内部类作为一个静态成员,因此可以用访问权限修饰符:public . private …….等。用的最多一般是private 引用静态内部类： Wapper.Inner 3、不能在非静态内部类中再定义静态内部类。静态内部类可以无限深度的嵌套下去。 提升 内部类最终会被javac编译为独立的类，JVM看见的都是top-level类。 编译后的class文件形如：WrapperClass $ InnerStaticClass.class 下面是使用静态内部类简单实现链式栈数据结构的例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class LinkedSatck&lt;E&gt; &#123; private static class Node&lt;T&gt; &#123; public Node(Node&lt;T&gt; next, T data) &#123; this.next = next; this.data = data; &#125; @SuppressWarnings(&quot;unused&quot;) public Node() &#123; this(null, null); &#125; private Node&lt;T&gt; next; private T data; public T getData() &#123; return data; &#125; public Node&lt;T&gt; getNext() &#123; return next; &#125; public boolean isEndNode() &#123; return (next == null); &#125; &#125; public LinkedSatck() &#123; topNode = new Node&lt;E&gt;(null, null); // size =0; &#125; private int size = 0; private Node&lt;E&gt; topNode = null; public void push(E e) &#123; Node&lt;E&gt; newTopNode = new Node&lt;E&gt;(topNode, e); ++size; topNode = newTopNode; &#125; public E pop() &#123; if (topNode.isEndNode()) return null; else &#123; E re = topNode.getData(); topNode = topNode.getNext(); --size; return re; &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; // return topNode.isEnd(); &#125;&#125; 成员内部类(inner member class)成员内部类最重要的特点就是它可以直接使用外部类的实例成员和static成员，即便是使用private修饰也是如此。 因为成员内部类总包含了一个外部类的当前对象引用 ，奇怪的名字 this$0，这个引用在成员内部类实例化时被外部类的当前对象引用this初始化。 大致实现如下：123456789101112class Outter&#123; private class Inner &#123; private final Outter this$0; //javac自动添加 Inner(Outter o) //javac自动添加 &#123; this.this$0 = o; &#125; &#125; //使用成员内部类对象时发生：new Inner(Outter.this)&#125; 这也是为什么在创建一个成员内部类对象时,要先创建一个外部类对象的原因了。 和普通实例成员一样，成员内部里是属于外部类的对象的，那么，在成员内部类就理所当然可以直接使用外部类的其他实例成员以及static成员。 因为是实例成员，所以可以使用访问修饰符:public 、protected、private、和默认的包访问权限。 因为是实例成员，因此，在类的外部使用内部类时，必须先创建1个外部类对象，在实际开发中很少使用这个。 1234567891011121314151617class Outter&#123; public class Inner &#123; &#125;&#125;public class Test &#123;public static void main(String[] args) &#123; Outter out = new Outter(); Outter.Inner in = out.new Inner(); &#125;&#125; 一个例子，自定义一个Str类，来支持迭代。12345678910111213141516171819202122232425262728293031323334353637383940414243class Str implements Iterable&lt;Character&gt;&#123; private String innerStr; public Str(String s) &#123; this.innerStr = (s==null?&quot;&quot;:s); &#125; private class StrIterator implements Iterator&lt;Character&gt; //迭代器类 作为成员内部类 &#123; private int curIndex = 0; @Override public boolean hasNext() &#123; return curIndex &lt; innerStr.length(); //直接访问外部类的成员 innerStr &#125; @Override public Character next() &#123; return innerStr.charAt(curIndex++); //直接访问外部类的成员 innerStr &#125; @Override public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; @Override public Iterator&lt;Character&gt; iterator() &#123; return new StrIterator(); &#125; &#125; 成员内部类中不能有static成员，即不能有static方法 和 static字段（除非static字段修饰为static final，那样的话它只不过是一个符号常量罢了）。因为java中类的静态成员必须定义在一个top-level顶层类中，而成员内部类（包括后面的方法内部类，匿名内部类）不是top-level顶层类。 static成员需要定义在top-level类中，而成员内部类不是top-level类。 提升 JVM是不理解nested类型的，也就是在它看来，所有的类型都是top-level的， 在每一个成员内部类中，javac都会自动添加一个字段：this$0，用来引用外部类当前对象。同时， 内部类的构造函数会自动为这个字段添加一个参数，当构造内部类对象时， 外部类当前对象就会传递给this$0，让这个字段引用外部类当前实例对象。 从这点我们也会发现，为什么要实例化一个成员内部类前，需要先实例化一个外部类对象。因为成员内部包含了一个外部类对象。 编译后的class文件形如：WrapperClass $ InnerClass.class 局部内部类(local inner class)定义在一个方法（包括了类的构造块和static构造块）内部的类，叫局部内部类。它不能有任何访问权限修饰符，因为它只能被包装它的方法使用，离开方法后就不可用了。 局部内部类可以和成员内部类一样，访问外部类的实例成员。同时，它还能直接使用包含它的方法的局部final常量,final参数。javac会复制使用了的外部方法的局部final量保存在局部内部类中作为私有的备份。 因此,当这个外部方法执行完毕后，虽然方法中的局部变量的 lifetime结束了，但是如果局部类的实例作为返回值,它会带着外部方法的局部final量离开这个局部作用域,也就是说,局部变量的生命延长到了和局部内部类的对象的生命周期一致。并不会随着方法执行完立刻被清理掉。我们可以以此来形成闭包。 同样,局部内部类不是top-level类，不能有static成员，除非是static final 字段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Main&#123; public static void main(String[] args) &#123; MsgGenerator g5 = fac(5); System.out.println(g5.generatorMsg()); MsgGenerator g2 = fac(2); System.out.println(g2.generatorMsg()); &#125; public static MsgGenerator fac(final int times) &#123; class Generator implements MsgGenerator &#123; @Override public StringBuffer generatorMsg() &#123; StringBuffer s= new StringBuffer() ; for(int i=0;i&lt;times;++i) &#123; s.append(&quot;hello &quot;); &#125; return s; &#125; &#125; //end of class return new Generator(); //向外发出闭包 &#125; &#125;interface MsgGenerator&#123; StringBuffer generatorMsg();&#125; 提升： 局部内部类之所以能访问外部类的实例成员，其原因和成员内部类是一样的：内部类中有保存了外部类对象的引用。除此之外，局部内部类还能访问包装方法的final字段，javac会将内部类使用了的final 局部常量拷贝到局部内部类中保存，并在局部内部类对象实例化时，初始化这些final常量。因此，局部内部类使用的final常量是自己的拷贝分。 局部内部类的实现原理（模拟） 12345678910111213141516171819202122232425262728293031323334class Wapper&#123; public void wapperFunction() //在方法中定义一个局部类 &#123; final int x = 10; class Local //局部类 &#123; private final int local_copy_x; //假如在局部类中使用了局部常量x，则javac自动生成 private final Wapper this$0; //javac自动生成的字段，用于保存外部类当前对象引用 //首先，局部内部类必定会包含外部类对象，着就是javac插入的第一个构造参数，这是必定的。 //其次，如果我们在局部内部类中使用了包装方法foo中的局部final常量，如x，则会在局部类中 //自动添加隐藏字段local_copy_x，并在构造器中初始化它。 Local(Wapper w,final int x) &#123; this$0 = w; local_copy_x = x; &#125; &#125;//end of Local new Local(); //当实例化局部内部类对象时，等价于 new Local(Wapper.this,x) &#125; &#125; 所以，之所以能在局部内部类中访问外部类的实例，是因为javac自动添加并用外部类当前对象this初始化了局部内部类的字段this$0，这样this$0就引用了外部类当前对象。 局部内部类能使用包装 方法的final字段，也是因为javac自动在局部内部类中添加并初始化的结果。 匿名内部类 (inner anonymous class)匿名内部类是特殊的局部内部类,它没有类名。它的访问特性和局部内类一样。如果只会使用类的一个对象,则可以使用匿名内部类,没有名称避免了再引入一个类名称， 匿名内部类是没有名称的局部内部类，访问特性与局部内部类一样。 因为没有类名,因此只能使用父类名或者接口名来创建对象。 new + superClass 或者 new+interface 。创建对象 是 使用new表达式。 new 表达式:匿名类对象的创建方式是使用new表达式,创建对象的同时也是类结构的编写。表达式的值是一个匿名类对象的引用。 1new SuperClass(param1，param2)&#123; 类体 &#125; 一般来说,匿名类没有构造参数,如果有,则传递给他的父类的构造函数。 匿名内部类由于没有类名，所以你不能定义新的构造函数，只能有默认的构造函数（javac添加的）。补救的做法是使用构造块。 下面是使用swing 中的Timer定时触发回调函数的例子，使用匿名类创建 ActionListener对象。程序每经过1000ms，就会调用 ActionListener对象的actionPerformed方法。 123456789101112131415161718192021222324public static void main(String[] args) &#123; //javax.swing.Timer; Timer t = new Timer(1000, new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; Toolkit.getDefaultToolkit().beep(); //系统响铃声 &#125; &#125; ); t.start(); while(true) &#123; &#125; &#125; 内部类的工作原理内部类只是Java的语法糖，jvm是不理解内部类的，它所看见的都是top-level顶层类。将内部类分离为单独的顶层类，是javac 的任务。内部类被javac合成为单独的类，并形成独立的class文件，这个文件有独特的名称，形式如下： static内部类: OutterClass$InnerClass.class 成员内部类：OutterClass$InnerClass.class 局部内部类: OutterClass$XInnerClass.class # X为一个正整数 局部内部类: OutterClass$X.class # X为一个正整数 对于static内部类，无需多解释，因为 static内部类和外部类是无依赖关系的，static内部类不包含外部类引用，javac只是将他们简单的分离。 成员内部类为什么能访问外部类的成员？因为内部类会被javac自动插入一个字段this&amp;0去保存外部类当前对象this的引用。 1234567891011121314public class OutterClass&#123; private int outFiled = 100; public class InnerClass &#123; public void f() &#123; int i = outFiled; &#125; &#125;&#125; javap反编译后的结果12345678910111213141516171819202122232425Compiled from &quot;OutterClass.java&quot;public class OutterClass$InnerClass &#123; final OutterClass this$0; //由javac自动合成：内部类包含1个外部类的当前对象的引用this&amp;0，使用this&amp;0避免和this冲突 //javac自动合成：合成的构造函数，有1个外部类参数，用于初始化 this&amp;0，this&amp;0被赋值为OutterClass.this public OutterClass$InnerClass(OutterClass); Code: 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LOutterClass; 5: aload_0 6: invokespecial #2 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: return public void f(); Code: 0: aload_0 1: getfield #1 // Field this$0:LOutterClass; 4: invokestatic #3 // Method OutterClass.access$000:(LOutterClass;)I 7: istore_1 8: return &#125; 局部内部类和匿名内部类除了可以访问外部类的成员（原因和成员内部类是相同的），还可以访问外部方法的局部final量和final参数。原因如下： A local class can use local variables because javac automatically gives the class aprivate instance field to hold a copy of each local variable the class uses.The compiler also adds hidden parameters to each local class constructor to initial‐ize these automatically created private fields. A local class does not actually accesslocal variables but merely its own private copies of them. This could cause inconsis‐tencies if the local variables could alter outside of the local class. -- 《Java int a Nutshell》 因为javac会自动在（局部和匿名）内部类中插入私有 的实例字段来保存 使用了的外部方法的final量的拷贝。javac还会在（局部和匿名）内部类中的构造函数的添加参数来初始化插入的私有 的字段。所以，（局部和匿名）内部类使用的实质是自己获得的拷贝量，而不是直接使用外部方法的final量。如果外部方法的量不修饰为final的话，那么意味着它的值可以改变，这就可能会导致（局部和匿名）内部类中获得的拷贝和外部方法不一致。所以java强制要求只能使用final量。 静态内部类和非静态内部类的区别如果你不需要内部类对象与其外围类对象之间有联系，那你可以将内部类声明为static。这通常称为嵌套类（nested class）。Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。想要理解static应用于内部类时的含义，你就必须记住，普通的内部类对象隐含地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static的时，就不是这样了。嵌套类意味着： 嵌套类的对象，并不需要其外围类的对象。 不能从嵌套类的对象中访问非静态的外围类对象。 123456789101112131415161718192021222324252627282930313233343536373839public class StaticTest&#123; private static String name = &quot;woobo&quot;; private String num = &quot;X001&quot;; static class Person&#123; // 静态内部类可以用public,protected,private修饰 // 静态内部类中可以定义静态或者非静态的成员 private String address = &quot;China&quot;;Private Static String x=“as”; public String mail = &quot;kongbowoo@yahoo.com.cn&quot;;//内部类公有成员 public void display()&#123; //System.out.println(num);//不能直接访问外部类的非静态成员// 静态内部类不能访问外部类的非静态成员(包括非静态变量和非静态方法) System.out.println(name);//只能直接访问外部类的静态成员//静态内部类只能访问外部类的静态成员(包括静态变量和静态方法) System.out.println(&quot;Inner &quot; + address);//访问本内部类成员。 &#125; &#125; public void printInfo()&#123; Person person = new Person();// 外部类访问内部类的非静态成员:实例化内部类即可 person.display(); //System.out.println(mail);//不可访问 //System.out.println(address);//不可访问 System.out.println(person.address);//可以访问内部类的私有成员System.out.println(Person.x);// 外部类访问内部类的静态成员：内部类.静态成员 System.out.println(person.mail);//可以访问内部类的公有成员 &#125; public static void main(String[] args)&#123; StaticTest staticTest = new StaticTest(); staticTest.printInfo(); &#125;&#125; 在静态嵌套类内部, 不能访问外部类的非静态成员, 这是由Java语法中”静态方法不能直接访问非静态成员”所限定.注意, 外部类访问内部类的的成员有些特别, 不能直接访问, 但可以通过内部类实例来访问, 这是因为静态嵌套内的所有成员和方法默认为静态的了.同时注意, 内部静态类Person只在类StaticTest 范围内可见, 若在其它类中引用或初始化, 均是错误的.一 . 静态内部类可以有静态成员，而非静态内部类则不能有静态成员。二 . 静态内部类的非静态成员可以访问外部类的静态变量，而不可访问外部类的非静态变量； 三 . 非静态内部类的非静态成员可以访问外部类的非静态变量。 生成一个静态内部类不需要外部类成员：这是静态内部类和成员内部类的区别。静态内部类的对象可以直接生成：Outer.Inner in = new Outer.Inner();而不需要通过生成外部类对象来生成。这样实际上使静态内部类成为了一个顶级类(正常情况下，你不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分，因为它是static 的。只是将嵌套类置于接口的命名空间内，这并不违反接口的规则） 原文地址：http://www.cnblogs.com/WuXuanKun/p/6220964.html","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/tags/Java/"},{"name":"内部类","slug":"内部类","permalink":"https://devallever.github.io/tags/内部类/"}]},{"title":"Android练手项目 极简天气","slug":"myCoolWeather","date":"2017-04-26T04:07:24.000Z","updated":"2017-05-10T04:15:23.495Z","comments":true,"path":"2017/04/26/myCoolWeather/","link":"","permalink":"https://devallever.github.io/2017/04/26/myCoolWeather/","excerpt":"","text":"项目地址: https://github.com/devallever/MyCoolWeather 下载apk 我的博客: https://devallever.github.io/ 简介极简天气, 天气应用,是我看完Android第一行代码后, 参考并修改的练习项目, 以巩固所学知识 感谢开源 OkHttp Retrofit Glide RxJava/RxAndroid LitePal EventBus 感谢郭神提供天气数据接口 功能第一版 显示实时天气, 三天预报, 空气质量, 温馨提示 获取Bing每日图片 滑动切换城市 城市管理: 增加,删除 下拉刷新 缓存省市县, 天气信息 第二版 后台自动刷新 自动下载壁纸 刷新天气随机更换壁纸 天气提醒 查看历史天气 关于 已知bug在主界面旋转屏幕时候, 报错找不到数据1weatherList = DataSupport.where(&quot;weatherId = ? &quot;, weather_id).find(Weather.class); 我想应该是旋转时候Activity和Fragment重新运行导致,weatherId空了, 导致查不到数据然而我在Activity的onSaveInstanceState方法中保存了临时数据并在onCreate中进行数据恢复,还是不行 功能实现细节第二版功能细节后台自动更新天气信息使用服务, 启动服务后通过AlarmManager设置一个定时任务,每隔一小时更新天气信息, 在退出程序时候启动该服务,在服务中主要执行了两个方法分别更新天气信息和壁纸, 请求网络后把数据保存到Weather表中12345678910111213141516@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, &quot;onStartCommand: ()&quot;); updateWeather(); updateImage(); int anHour = 1 * 60 * 60 * 1000; //１小时 //int anHour = 10* 1000; //10秒 long triggerAtTime = SystemClock.elapsedRealtime() + anHour; AlarmManager alarmManager = (AlarmManager) getSystemService(ALARM_SERVICE); Intent serviceIntent = new Intent(this, AutoUpdateService.class); //Intent receiverIntent = new Intent(this, AutoUpdateReceiver.class); PendingIntent pendingIntent = PendingIntent.getService(this,0,serviceIntent,0); alarmManager.cancel(pendingIntent); alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime,pendingIntent); return super.onStartCommand(intent, flags, startId);&#125; 启动服务1234567@Overrideprotected void onDestroy() &#123; //启动后台更新服务 Intent serviceIntent = new Intent(this, AutoUpdateService.class); startService(serviceIntent); super.onDestroy();&#125; 天气提醒功能每次后台获取更新后,判断该城市是否显示通知, 是的话就对天气信息进一步分析: 昼夜温度大于10度时提醒,1234567int max = Integer.valueOf(newWeather.getDaily_forecast().get(0).getTmp().getMax());int min = Integer.valueOf(newWeather.getDaily_forecast().get(0).getTmp().getMin());if ((max-min) &gt;=10 )&#123;//显示通知builder.setContentText( county + &quot;: 昼夜温差较大,请预防感冒!&quot;);notificationManager.notify(id,builder.build());&#125; 今明天气相差5度时提醒12345678910111213//2.比较今天明天气温相差5度提示Daily_forecast today = newWeather.getDaily_forecast().get(0);Daily_forecast tomorrow = newWeather.getDaily_forecast().get(1);int todayTmp = Integer.valueOf(today.getTmp().getMin());int tomorrowTmp = Integer.valueOf(tomorrow.getTmp().getMin());if ( Math.abs(todayTmp-tomorrowTmp) &gt;= 5)&#123; if (tomorrowTmp &gt; todayTmp)&#123; builder.setContentText( county + &quot;: 明天将大幅度升温!&quot;); &#125;else &#123; builder.setContentText( county + &quot;: 明天将大幅度降温温!&quot;); &#125;notificationManager.notify(id+1000,builder.build());&#125; 有降水提示带伞12345//3. 有雨的要带伞if (tomorrow.getCond().getTxt_d().contains(&quot;雨&quot;))&#123; builder.setContentText( county + &quot;: 明天将有&quot; + tomorrow.getCond().getTxt_d() + &quot;, 出门记得带伞.&quot;); notificationManager.notify(id+1001,builder.build());&#125; 当实时天气与上一次的天气有不同时候,提醒1234567//4. 比较实时天气String old = oldWeather.getNow().getCond().getTxt();String newInfo = newWeather.getNow().getCond().getTxt();if (!old.equals(newInfo))&#123; builder.setContentText( county + &quot;: &quot; + newWeather.getNow().getCond().getTxt()); notificationManager.notify(id+1002,builder.build());&#125; 查看历史天气创建一个数据库表HistoryWeather用来保存历史天气信息id, weatherId, countyName, date, weatehr, min, max每次后台自动更新天气数据时候，解析json数据，获取所需数据封装成HIstoryWeather，然后保存，根据date和weatherId字段获取要保存的记录，如果存在的就更新，不存在的就天机记录123456789101112131415161718192021222324private void saveHistoryWeather(String result)&#123; Gson gson = new Gson(); HeWeather5 heWeather5 = gson.fromJson(result,Root.class).getHeWeather5().get(0); List&lt;Daily_forecast&gt; daily_forecastList = heWeather5.getDaily_forecast(); //for (Daily_forecast daily_forecast :daily_forecastList)&#123; Daily_forecast today = daily_forecastList.get(0); String date = today.getDate(); String weather = today.getCond().getTxt_d(); String weatherId = heWeather5.getBasic().getId(); String countyName = heWeather5.getBasic().getCity(); String min = today.getTmp().getMin(); String max = today.getTmp().getMax(); HistoryWeather historyWeather = new HistoryWeather(); historyWeather.setDate(date); historyWeather.setWeatherId(weatherId); historyWeather.setCountyName(countyName); historyWeather.setWeather(weather); historyWeather.setMin(min); historyWeather.setMax(max); historyWeather.saveOrUpdate(&quot;weatherId=? and date=?&quot;, weatherId, date); //&#125;&#125; 查找历史天气信息时候，默认是查找前30条记录，并且按date降序排列12345678910List&lt;HistoryWeather&gt; historyWeatherList;historyWeatherList = DataSupport.where(&quot;weatherId=? order by date desc&quot;, weatherId).find(HistoryWeather.class);for (HistoryWeather historyWeather: historyWeatherList)&#123; HistoryWeatherItem historyWeatherItem = new HistoryWeatherItem(); historyWeatherItem.setWeather(historyWeather.getWeather()); historyWeatherItem.setDate(historyWeather.getDate()); historyWeatherItem.setMax(historyWeather.getMax()); historyWeatherItem.setMin(historyWeather.getMin()); historyWeatherItemList.add(historyWeatherItem);&#125; 第一版功能细节选择城市 ChooseCItyActivity首先访问数据库中是否有所有省份数据,有则获取,没有则请求服务器,然后得到全国省份的json数据,保存到数据库中12345678910111213141516private void queryProvince()&#123; toolbar.setTitle(&quot;中国&quot;); provinceList = DataSupport.findAll(Province.class); if (provinceList.size() &gt; 0)&#123; dataList.clear(); for (Province province:provinceList)&#123; dataList.add(province.getProvinceName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_PROVINCE; &#125;else &#123; String address = &quot;http://guolin.tech/api/china/&quot;; queryFromServer(address, &quot;province&quot;); &#125;&#125; 123456789101112131415161718public static boolean handleProvinceResponse(String response)&#123; if (!TextUtils.isEmpty(response))&#123; try &#123; JSONArray allProvince = new JSONArray(response); for (int i = 0; i&lt;allProvince.length(); i++)&#123; JSONObject provinceObject = allProvince.getJSONObject(i); Province province = new Province(); province.setProvinceCode(provinceObject.getInt(&quot;id&quot;)); province.setProvinceName(provinceObject.getString(&quot;name&quot;)); province.save(); &#125; return true; &#125;catch (JSONException je)&#123; je.printStackTrace(); &#125; &#125; return false;&#125; 然后解析json数据,设置到Listview中,点击时记录省份id, 然后根据这个id访问数据库中是否有该省份的城市信息,有则获取,没有则请求服务器,然后得到该省份所有城市的json数据,保存到数据库中 1234567891011121314151617private void queryCity()&#123; toolbar.setTitle(selectedProvince.getProvinceName()); cityList = DataSupport.where(&quot;provinceCode = ? &quot;, String.valueOf(selectedProvince.getProvinceCode())).find(City.class); if (cityList.size() &gt; 0)&#123; dataList.clear(); for (City city: cityList)&#123; dataList.add(city.getCityName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_CITY; &#125;else &#123; int provinceCode = selectedProvince.getProvinceCode(); String address = &quot;http://guolin.tech/api/china/&quot; + provinceCode; queryFromServer(address,&quot;city&quot;); &#125;&#125; 1234567891011121314151617181920public static boolean handleCityResponse(String response, int provinceCode)&#123; if (!TextUtils.isEmpty(response))&#123; try &#123; Log.d(TAG, &quot;handleCityResponse: \\n response = &quot; + response); JSONArray allCity = new JSONArray(response); for (int i = 0; i&lt; allCity.length(); i++)&#123; JSONObject cityObject = allCity.getJSONObject(i); City city = new City(); city.setCityCode(cityObject.getInt(&quot;id&quot;)); city.setCityName(cityObject.getString(&quot;name&quot;)); city.setProvinceCode(provinceCode); city.save(); &#125; return true; &#125;catch (JSONException je)&#123; je.printStackTrace(); &#125; &#125; return false;&#125; 然后解析json数据,清空listview数据源, 然后加载该省的所有城市数据,设置到ListView中,点击时记录该市的id, 然后根据这个id访问数据库中是否存在该市的所有县数据,有则获取, 没有则请求服务器,然后得到该市所有县的json数据,保存到数据库中 1234567891011121314151617181920private void queryCounty()&#123; toolbar.setTitle(selectedCity.getCityName()); Toast.makeText(this,&quot;cityCode = &quot;+ selectedCity.getCityCode() + &quot;\\n&quot; + &quot;id = &quot; + selectedCity.getId(),Toast.LENGTH_LONG ).show(); countyList = DataSupport.where(&quot;cityCode = ?&quot;, String.valueOf(selectedCity.getId())).find(County.class); if (countyList.size() &gt; 0 )&#123; dataList.clear(); for (County county: countyList)&#123; dataList.add(county.getCountyName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_COUNTY; &#125;else &#123; int provinceCode = selectedProvince.getProvinceCode(); int cityCode = selectedCity.getCityCode(); String address = &quot;http://guolin.tech/api/china/&quot; + provinceCode + &quot;/&quot; + cityCode; queryFromServer(address,&quot;county&quot;); &#125;&#125; 123456789101112131415161718192021public static boolean handleCountyResponse(String response, int cityCode)&#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allCounty = new JSONArray(response); for (int i = 0; i &lt; allCounty.length(); i++) &#123; JSONObject countyObject = allCounty.getJSONObject(i); County county = new County(); county.setCountyName(countyObject.getString(&quot;name&quot;)); county.setWeatherId(countyObject.getString(&quot;weather_id&quot;)); county.setCityCode(cityCode); boolean successed = county.save(); if (successed) Log.d(TAG, &quot;handleCountyResponse: save success&quot;); else Log.d(TAG, &quot;handleCountyResponse: save fail&quot;); &#125; return true; &#125; catch (JSONException je) &#123; je.printStackTrace(); &#125; &#125; return false;&#125; 选择其中某一项, 获取weatherId和县名称countyName, 通过setResult返回父Activity中,在父Activity中onActivityResult方法中, 把weatherId和countyName保存到Weather数据表中, 然后重新获取weather表中数据. 1234567891011121314151617181920212223242526listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; if (currentLevel == LEVEL_PROVINCE)&#123; selectedProvince = provinceList.get(position); queryCity(); &#125;else if (currentLevel == LEVEL_CITY)&#123; selectedCity = cityList.get(position); Toast.makeText(ChooseCityActivity.this,&quot;id = &quot; + selectedCity.getId() + &quot;\\n&quot;+ &quot;cityName = &quot; + selectedCity.getCityName() + &quot;\\n&quot; + &quot;cityCode = &quot; + selectedCity.getCityCode() + &quot;\\n&quot; + &quot;provinceCode = &quot; + selectedCity.getProvinceCode(),Toast.LENGTH_SHORT).show(); queryCounty(); &#125;else if (currentLevel == LEVEL_COUNTY)&#123; selectedCounty = countyList.get(position); Toast.makeText(ChooseCityActivity.this,&quot;id = &quot; + selectedCounty.getId() + &quot;\\n&quot;+ &quot;countyName = &quot; + selectedCounty.getCountyName() + &quot;\\n&quot; + &quot;weather_id = &quot; + selectedCounty.getWeatherId(),Toast.LENGTH_SHORT).show(); Intent intent = new Intent(); intent.putExtra(&quot;weather_id&quot;, selectedCounty.getWeatherId()); intent.putExtra(&quot;county_name&quot;,selectedCounty.getCountyName()); setResult(RESULT_OK,intent); finish(); &#125; &#125;&#125;); 回到父Activity进行操作12345678910111213String weather_id = data.getStringExtra(&quot;weather_id&quot;);List&lt;Weather&gt; weatherList = DataSupport.where(&quot;weatherId = ? &quot;, weather_id).find(Weather.class);if (weatherList != null &amp;&amp; weatherList.size()==0)&#123; Weather weather = new Weather(); weather.setCountyName(data.getStringExtra(&quot;county_name&quot;)); weather.setWeatherId(data.getStringExtra(&quot;weather_id&quot;)); weather.setIsShow(&quot;1&quot;); weather.save(); titleList.add(weather.getCountyName()); WeatherFragment weatherFragment = new WeatherFragment(weather.getWeatherId()); weatherFragmentList.add(weatherFragment); weatherPageAdapter.notifyDataSetChanged();&#125; 构造ViewPager天气页面数据源在MainActivity中,访问数据库weather表, (条件:isShow=1,表示显示是否显示在主界面), 把查询结果存到List中,如果list大小为0, 则打开选择城市界面,如果存在数据,则遍历每个weather对象,创建WeatherFragment,并把weather对象中的weatherId传到Fragment的构造方法中,并添加到fragmengList中, WeatherFragment会根据这个weatherId获取天气信息,同时把weather的countyName添加到titleLists中用于设置每个pager的标题,,,然后通知adapter数据更新了,pagerAdapter是通过fragmengList和titleList绑定数据的 123456789101112131415161718private void showWeather()&#123; weatherList.clear(); weatherFragmentList.clear(); titleList.clear(); weatherList = DataSupport.where(&quot;isShow=?&quot;, &quot;1&quot;).find(Weather.class); if (weatherList.size() ==0)&#123; //转到选择城市Activity Intent intent = new Intent(this, ChooseCityActivity.class); startActivityForResult(intent, REQUEST_CODE_CHOOSE_CITY); &#125;else &#123; for (Weather weather: weatherList) &#123; titleList.add(weather.getCountyName()); WeatherFragment weatherFragment = new WeatherFragment(weather.getWeatherId()); weatherFragmentList.add(weatherFragment); &#125; weatherPageAdapter.notifyDataSetChanged(); &#125;&#125; 选择城市后返回的操作12345678910111213String weather_id = data.getStringExtra(&quot;weather_id&quot;);List&lt;Weather&gt; weatherList = DataSupport.where(&quot;weatherId = ? &quot;, weather_id).find(Weather.class);if (weatherList != null &amp;&amp; weatherList.size()==0)&#123; Weather weather = new Weather(); weather.setCountyName(data.getStringExtra(&quot;county_name&quot;)); weather.setWeatherId(data.getStringExtra(&quot;weather_id&quot;)); weather.setIsShow(&quot;1&quot;); weather.save(); titleList.add(weather.getCountyName()); WeatherFragment weatherFragment = new WeatherFragment(weather.getWeatherId()); weatherFragmentList.add(weatherFragment); weatherPageAdapter.notifyDataSetChanged();&#125; 城市管理-CityManageActivity该页面有一个RecyclerView,和一个FloatingActionButton, 其中recyclerView的item是一个CardView, 显示了该城市粗略的天气信息,如温度和天气,fab用于添加城市,可以通过左右滑动每一个卡片来删除数据,请求数据库, 访问weather表的所有数据, 抽取其中所需的信息封装到CityItem中,然后添加到cityItemList中,作为RecyclerView的数据源,当成功选择一个城市并返回后,根据返回的weatherId访问数据库是否存在该数据,有则不操作,没有则添加到weather表中.以免产生冗余数据.当滑动删除城市后,会从数据表中删除掉这条记录,(改进的做法是滑动删除后显示一个Snackbar来确认操作)12345678910111213141516weatherList = DataSupport.findAll(Weather.class);Gson gson = new Gson();Root root;for (Weather weather: weatherList)&#123; CityItem cityItem = new CityItem(); cityItem.setIsShow(weather.getIsShow()); root = gson.fromJson(weather.getWeatherInfo(),Root.class); if (root!=null)&#123; cityItem.setTmp(root.getHeWeather5().get(0).getNow().getTmp()); cityItem.setWeather(root.getHeWeather5().get(0).getNow().getCond().getTxt()); cityItem.setCounty(weather.getCountyName()); cityItem.setWeatherId(weather.getWeatherId()); cityItemList.add(cityItem); &#125;&#125;cityRecyclerAdapter.notifyDataSetChanged(); 滑动删除后的操作-我还在进一步研究,不是很懂,因为是复制别人的代码关联1234//关联ItemTouchHelper和RecyclerViewItemTouchHelper.Callback callback = new ItemTouchHelperCallback(cityRecyclerAdapter);ItemTouchHelper mItemTouchHelper = new ItemTouchHelper(callback);mItemTouchHelper.attachToRecyclerView(recyclerView); ItemTouchHelperCallback:1234567891011121314151617181920212223242526272829303132333435363738394041public class ItemTouchHelperCallback extends ItemTouchHelper.Callback &#123; private OnMoveAndSwipedListener moveAndSwipedListener; public ItemTouchHelperCallback(OnMoveAndSwipedListener listener) &#123; this.moveAndSwipedListener = listener; &#125; //设置拖动方向以及侧滑方向 @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; if (recyclerView.getLayoutManager() instanceof LinearLayoutManager) &#123; //单列的RecyclerView支持上下拖动和左右侧滑 final int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; final int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END; return makeMovementFlags(dragFlags, swipeFlags); &#125; else &#123; //多列的RecyclerView支持上下左右拖动和不支持左右侧滑 final int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; final int swipeFlags = 0; return makeMovementFlags(dragFlags, swipeFlags); &#125; &#125; //拖动item时会调用此方法 @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; //如果两个item不是同一个类型的，不让他拖拽 if (viewHolder.getItemViewType() != target.getItemViewType()) &#123; return false; &#125; moveAndSwipedListener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition()); return true; &#125; //侧滑item时会调用此方法 @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; moveAndSwipedListener.onItemDismiss(viewHolder.getAdapterPosition()); &#125;&#125; OnMoveAndSwipedListener:1234567public interface OnMoveAndSwipedListener &#123; boolean onItemMove(int fromPosition, int toPosition); void onItemDismiss(int position);&#125; 监听到滑动删除执行以下方法123456789101112@Overridepublic boolean onItemMove(int fromPosition, int toPosition) &#123; notifyItemMoved(fromPosition, toPosition); return true;&#125;@Overridepublic void onItemDismiss(int position) &#123; DataSupport.deleteAll(Weather.class,&quot;weatherId=?&quot;,cityItemList.get(position).getWeatherId()); cityItemList.remove(position); notifyItemRemoved(position);&#125; 显示天气-WeatherFragmeng显示天气信息是在WeatherFragment中完成的, 也就是每个页面. 从构造方法中获取到该所显示城市的天气数据, 根据这个weatherId访问数据库中该weatherId所在记录是否有weatherInfo信息,如果有则获取该天气信息的json数据, 没有则向服务器请求数据,获取天气信息,成功获取信息之后保存到数据库中. 12345678weatherList = DataSupport.where(\"weatherId = ? \", weather_id).find(Weather.class);if (weatherList != null &amp;&amp; weatherList.size()&gt;0)&#123; if (TextUtils.isEmpty(weatherList.get(0).getWeatherInfo())) sendWeatherInfoRequest(); else handleWeatherInfoResponse(weatherList.get(0).getWeatherInfo());&#125;else &#123; //get dada from internet sendWeatherInfoRequest();&#125; 获取后保存到数据库12345678910String responseText = response.body().string();Weather weather = new Weather();weather.setWeatherInfo(responseText);weather.updateAll(\"weatherId=?\", weather_id);getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; handleWeatherInfoResponse(responseText); &#125;&#125;); 持续更新……..欢迎大家共同学习共同成长…..","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Project","slug":"Project","permalink":"https://devallever.github.io/tags/Project/"}]},{"title":"滚动屏幕自动隐藏FloatingActionButton","slug":"fab-auto-hideshow","date":"2017-04-24T01:56:01.000Z","updated":"2017-04-24T03:50:43.817Z","comments":true,"path":"2017/04/24/fab-auto-hideshow/","link":"","permalink":"https://devallever.github.io/2017/04/24/fab-auto-hideshow/","excerpt":"","text":"概述FloatingActionButton可以说是Material Design 的标志之一了，但是却有很多人并不是很喜欢它，其中一条主要的原因就是FAB的存在挡住了要显示的内容，从而影响体验。本文主要介绍对FAB两方面的优化，一方面是点击FAB弹出子菜单的特效，一方面是在滑动时自动隐藏FAB。最终的实现 原理 它的显示与隐藏是根据AppBarLayout的Y值来决定的，我们知道如果按照最上面的方式定义主界面布局，列表滚动的时候toolbar会显示和隐藏，而toolbar是AppBarLayout的一部分，因此可以让Behavior依赖于AppBarLayout，当AppBarLayout变化的时候会调用onDependentViewChanged，然后在这里获取AppBarLayout的高度移动的距离，然后根据这个距离来判定FloatingActionButton上下移动的距离，从而实现了FloatingActionButton的显示和隐藏。这个实现方式我是在这里找到的： http://stackoverflow.com/questions/31457099/android-fab-to-hide-when-navigating-between-different-fragments-in-a-viewpager 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class FABVerticalBehavior extends FloatingActionButton.Behavior &#123; private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator(); private boolean mIsAnimatingOut = false; public FABVerticalBehavior(Context context, AttributeSet attrs) &#123; super(); &#125; @Override public boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View directTargetChild, final View target, final int nestedScrollAxes) &#123; // Ensure we react to vertical scrolling return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); &#125; @Override public void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0 &amp;&amp; !this.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123; // User scrolled down and the FAB is currently visible -&gt; hide the FAB animateOut(child); &#125; else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; // User scrolled up and the FAB is currently not visible -&gt; show the FAB animateIn(child); &#125; &#125; // Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exits private void animateOut(final FloatingActionButton button) &#123; if (Build.VERSION.SDK_INT &gt;= 14) &#123; ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer() .setListener(new ViewPropertyAnimatorListener() &#123; public void onAnimationStart(View view) &#123; FABVerticalBehavior.this.mIsAnimatingOut = true; &#125; public void onAnimationCancel(View view) &#123; FABVerticalBehavior.this.mIsAnimatingOut = false; &#125; public void onAnimationEnd(View view) &#123; FABVerticalBehavior.this.mIsAnimatingOut = false; view.setVisibility(View.GONE); &#125; &#125;).start(); &#125; else &#123; &#125; &#125; // Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout enters private void animateIn(FloatingActionButton button) &#123; button.setVisibility(View.VISIBLE); if (Build.VERSION.SDK_INT &gt;= 14) &#123; ViewCompat.animate(button).translationY(0) .setInterpolator(INTERPOLATOR).withLayer().setListener(null) .start(); &#125; else &#123; &#125; &#125; private int getMarginBottom(View v) &#123; int marginBottom = 0; final ViewGroup.LayoutParams layoutParams = v.getLayoutParams(); if (layoutParams instanceof ViewGroup.MarginLayoutParams) &#123; marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin; &#125; return marginBottom; &#125;&#125; 注意 在25.0.1以上版本的design包中，会有隐藏后不显示的Bug 参考这里","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"}]},{"title":"Android 应用开发所需的技能和自我评分","slug":"android-developer-base-skill-20","date":"2017-04-23T02:22:57.000Z","updated":"2017-04-23T02:57:07.828Z","comments":true,"path":"2017/04/23/android-developer-base-skill-20/","link":"","permalink":"https://devallever.github.io/2017/04/23/android-developer-base-skill-20/","excerpt":"","text":"Android 应用开发所需的技能和自我评分 参考: App研发录 评分标准每个技能点都是五分制 完全不知道:0分 听说过:1分 看过相关文章:2分 做过demo:3分 项目中使用过:4分 非常熟悉:5分 技能 描述 得分(4月23日) Activity相关 launchModel, onSaveInstanceState, 生命周期 3 Fragment相关 3 序列化技术 前者基于Service, 后者基于Bundle 1 ImageLoader原理与实现 Parcelable和Serialiable 1 fastJSO和GSON 4 多线程 Handler, Looper, ExecuteService等 3 Adapter和RecyclerView 3 Cookie 登录机制, HttpRequest夹带Cookie进行身份验证 3 网络请求封装 使用AsyncTask, 使用Handler+Runnable 1 Android与HTML5的交互 Android调用HTML5 和 HTML5调用Android 1 代码混淆 proGuard 1 打包机制 Android sdk 命令, 打包过程, Ant 或 Gradle 或 Maven 0 线上Crash分析和修复 分析Crash信息修复线上 Crash 0 内存泄漏 内存优化, 内存泄露, MAT 1 调试工具 DDMS 2 Monkey机制 Monkey测试 0 单元测试 JUnit 1 Git 2 插件化编程 DexClassLoader 0 设计模式 工厂, 生成器, 适配器, 代理, 策略, 观察者, 单例等 2","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"}]},{"title":"Material Design 笔记","slug":"material-design-note","date":"2017-04-21T14:08:13.000Z","updated":"2017-04-21T14:13:12.622Z","comments":true,"path":"2017/04/21/material-design-note/","link":"","permalink":"https://devallever.github.io/2017/04/21/material-design-note/","excerpt":"","text":"1.Toolbar的使用1.1设置应用的主题为NoActionBar1android:theme=&quot;@style/AppTheme&quot; 这个主题在sytle文件中定义123456&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;&lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorGreen_300&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorGreen700&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 1.2在布局文件中使用Toolbar控件1234567&lt;android.support.v7.widget.Toolbarandroid:id=&quot;@+id/id_material_design_activity_toolbar&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;?actionBarSize&quot;android:background=&quot;@color/colorGreen700&quot;android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; 1.3在Activity中这样用12Toolbar toolbar = (Toolbar)findViewById(R.id.id_material_design_activity_toolbar);setSupportActionBar(toolbar); 1.4设置toolbar的home图标并设置监听12345ActionBar actionBar = getSupportActionBar();if (actionBar != null)&#123;actionBar.setDisplayHomeAsUpEnabled(true);actionBar.setHomeAsUpIndicator(R.mipmap.ic_arrow_back_white_36dp);&#125; 在onOptionsItemSelected()方法中设置监听123case android.R.id.home:drawerLayout.openDrawer(GravityCompat.START);break; 1.5设置toolbar菜单1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/id_menu_notification&quot; android:title=&quot;Notification&quot; android:icon=&quot;@mipmap/ic_notifications_active_white_24dp&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/id_menu_sms&quot; android:title=&quot;Notification&quot; android:icon=&quot;@mipmap/ic_sms_white_24dp&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/id_menu_person&quot; android:title=&quot;Notification&quot; android:icon=&quot;@mipmap/ic_person_outline_white_24dp&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;/menu&gt; 然后在Activity中加载这个菜单 1234567891011121314151617181920212223242526@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar_menu,menu); return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); switch (id)&#123; case R.id.id_menu_notification: Toast.makeText(this,&quot;Notification&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_menu_sms: Toast.makeText(this,&quot;SMS&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_menu_person: Toast.makeText(this,&quot;Contacts&quot;,Toast.LENGTH_SHORT).show(); break; case android.R.id.home: drawerLayout.openDrawer(GravityCompat.START); break; &#125; return true;&#125; 2.DrawerLayout与NavigationView的爱恨情仇2.1在布局中使用DrawerLayout和NavigationView1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/id_material_design_activity_drawer_layout&quot;&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/id_material_design_activity_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?actionBarSize&quot; android:background=&quot;@color/colorGreen700&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/id_material_design_activity_fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/ic_notifications_active_white_24dp&quot; app:elevation=&quot;8dp&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/id_material_design_navigation_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:menu=&quot;@menu/nav_menu&quot; app:headerLayout=&quot;@layout/nav_header_layout&quot;/&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; 其中NavigationVIew包含一个menu菜单和头布局nav_menu.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/id_nav_menu_item_like&quot; android:icon=&quot;@mipmap/ic_favorite_black_24dp&quot; android:title=&quot;Like&quot;/&gt; &lt;item android:id=&quot;@+id/id_nav_menu_item_alarm&quot; android:icon=&quot;@mipmap/ic_alarm_black_24dp&quot; android:title=&quot;Alarm&quot;/&gt; &lt;item android:id=&quot;@+id/id_nav_menu_item_account&quot; android:icon=&quot;@mipmap/ic_account_circle_black_24dp&quot; android:title=&quot;Account&quot;/&gt; &lt;item android:id=&quot;@+id/id_nav_menu_item_setting&quot; android:icon=&quot;@mipmap/ic_build_black_24dp&quot; android:title=&quot;Setting&quot;/&gt; &lt;/group&gt; &lt;/menu&gt; nav_header_layout1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; android:padding=&quot;10dp&quot; android:background=&quot;@color/colorGreen700&quot;&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id=&quot;@+id/id_nav_header_iv_head&quot; android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:src=&quot;@mipmap/h_01&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;TextView android:id=&quot;@+id/id_nav_header_tv_email&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;devallever@163.com&quot; android:textColor=&quot;@color/white&quot; android:layout_alignParentBottom=&quot;true&quot;/&gt; &lt;TextView android:id=&quot;@+id/id_nav_header_tv_username&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;5dp&quot; android:text=&quot;Devallever&quot; android:textColor=&quot;@color/white&quot; android:layout_above=&quot;@id/id_nav_header_tv_email&quot;/&gt; &lt;/RelativeLayout&gt; 2.2设置NavigationView的菜单监听1234567891011121314151617181920212223navigationView = (NavigationView)findViewById(R.id.id_material_design_navigation_view);navigationView.setCheckedItem(R.id.id_nav_menu_item_like);navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; int id = item.getItemId(); switch (id)&#123; case R.id.id_nav_menu_item_like: Toast.makeText(MaterialDesignActivity.this, &quot;Like&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_nav_menu_item_account: Toast.makeText(MaterialDesignActivity.this, &quot;Account&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_nav_menu_item_alarm: Toast.makeText(MaterialDesignActivity.this, &quot;Alarm&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.id_nav_menu_item_setting: Toast.makeText(MaterialDesignActivity.this, &quot;Setting&quot;,Toast.LENGTH_SHORT).show(); break; &#125; return true; &#125;&#125;); 2.3把toolbar与NavigationView关联起来，并实现home的动画效果123ActionBarDrawerToggle actionBarDrawerToggle = new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.app_name, R.string.app_name);actionBarDrawerToggle.syncState(); 3FloatActionButton3.1在布局中使用FloatActionButton控件12345678&lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/id_material_design_activity_fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/ic_notifications_active_white_24dp&quot; app:elevation=&quot;8dp&quot;/&gt; 3.2设置监听，和一般的按钮设置监听是一样的123456fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 4Snackbar当点击按钮时候弹出Snackbar12345678910111213fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v, &quot;Remind!&quot;, Snackbar.LENGTH_INDEFINITE) .setAction(&quot;I know.&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MaterialDesignActivity.this,&quot;OK&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;) .show(); &#125;&#125;); 5CoordinatorLayout加强版的FrameLayout123456789101112131415161718192021&lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/id_material_design_activity_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?actionBarSize&quot; android:background=&quot;@color/colorGreen700&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/id_material_design_activity_fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@mipmap/ic_notifications_active_white_24dp&quot; app:elevation=&quot;8dp&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout","categories":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://devallever.github.io/tags/Android/"},{"name":"Material Design","slug":"Material-Design","permalink":"https://devallever.github.io/tags/Material-Design/"}]},{"title":"Markdown 教程","slug":"markdown-learn","date":"2017-04-21T08:32:17.000Z","updated":"2017-04-21T09:20:44.418Z","comments":true,"path":"2017/04/21/markdown-learn/","link":"","permalink":"https://devallever.github.io/2017/04/21/markdown-learn/","excerpt":"","text":"『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』 原文地址 Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 和 * 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： 我的头像 Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://devallever.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://devallever.github.io/tags/Markdown/"}]},{"title":"Java连接数据库","slug":"Java连接数据库","date":"2017-04-21T05:49:27.000Z","updated":"2017-04-21T09:20:14.465Z","comments":true,"path":"2017/04/21/Java连接数据库/","link":"","permalink":"https://devallever.github.io/2017/04/21/Java连接数据库/","excerpt":"","text":"MySQL provides standards-based drivers for JDBC, ODBC, and .Net enabling developers to build database applications in their language of choice. In addition, a native C library allows developers to embed MySQL directly into their applications. 1.下载相关的驱动程序如 Java与MySQL的连接,可到MySQL官网上下载下载地址 2.数据库的URL格式如: jdbc:mysql://127.0.0.1/dbname在连接数据库时,我们必须使用各种与数据库类型相关的参数,例如主机名,端口号和数据库名jdbc的一般语法:jdbc:subprotocol:other stuff subprotocol:连接数据库的具体驱动程序 other stuff:随subprotocol的不同而不同,应查阅供应商的相关文档 3.注册驱动器类1Class.forName(\"com.mysql.jdbc.Driver\"); 字符串的内容为驱动器类所在包的全路径这条语句使得驱动器类被加载,由此将执行可以注册驱动器的静态初始化器 4.连接到数据库1Connection conn = DriverManager.getConnection(sqlUrl, username, password); 以上三个参数类型都是字符串类型, 连接成功会返回Connection对象,用它去执行SQL语句. 5.操作数据库5.1 基本方法1String sql = \"select nickname, phone from tuser where username='xm'\"; 执行sql命令首先创建Statement对象或其子类PreparedStatement对象12345statement = conn.createStatement();preparedStatement = conn.preparedStatement(sql);ResultSet resultSet = statement.executeQuery(sql);或resultSet = preparedStatement.executeQuery(); executeQuery()方法可以执行select 语句, executeUpdate()方法可以执行insert, update和delete之类的操作. 也可以执行create table 和drop table之类的数据定义语句. execute()方法可以执行任意的sql语句.","categories":[{"name":"Java","slug":"Java","permalink":"https://devallever.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://devallever.github.io/tags/java/"},{"name":"sql","slug":"sql","permalink":"https://devallever.github.io/tags/sql/"}]},{"title":"Hello Android","slug":"helloAndroid","date":"2017-04-17T14:56:05.454Z","updated":"2017-04-17T14:56:05.438Z","comments":true,"path":"2017/04/17/helloAndroid/","link":"","permalink":"https://devallever.github.io/2017/04/17/helloAndroid/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-04-17T08:48:22.843Z","updated":"2017-04-17T08:48:22.843Z","comments":true,"path":"2017/04/17/hello-world/","link":"","permalink":"https://devallever.github.io/2017/04/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}